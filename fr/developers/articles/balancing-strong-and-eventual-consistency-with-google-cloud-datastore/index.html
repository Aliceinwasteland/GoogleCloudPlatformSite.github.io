<!DOCTYPE html>
<html lang="fr">
  <head>
    <title>Cloud Computing &amp; Cloud Hosting Services</title>
    <meta charset="utf-8" />
    
      <meta description="Google Cloud Platform lets you build and host applications and websites, store data, and analyze data on Google's scalable infrastructure.">
    
    <link rel="shortcut icon" href="/images/gcp-favicon.ico">
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">

    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->

    <meta name="google-site-verification" content="8dOEM3Xenm6yaBc83y2WKgqQG0iHI7Ph6Rl_YLIZLQ8" />
    <meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">

    <!-- GSAP animation frameworks -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="//www.gstatic.com/external_hosted/gsap/TweenMax.min.js"></script>
    <script src="//www.gstatic.com/external_hosted/gsap/TimelineMax.min.js"></script>
    <script src="/js/floodlight.js"></script>

    <link href="/fr/developers/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/" rel="canonical">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
    <link href="//www.google.com/css/maia.experimental.css" rel="stylesheet">
    <link href="/css/maia-cloud.css" rel="stylesheet"/>
    <link href="/css/default.css" rel="stylesheet">
  </head>
  <body>
  <div id="maia-header">
    <div class="maia-aux">
      <h1><a href="/"><img src="/images/gcp-logo.png" alt="Cloud Platform" data-retina="383x48"></a></h1>

<div class="search-container">
  <form action="/search" class="maia-search">
    <input type="text" placeholder="Search this site" name="q">
    <button class="maia-button" type="submit" data-g-event="Maia: Button" data-g-action="Maia: Primary – Header" data-g-label="Search">
      <span class="maia-search-icon">Rechercher</span>
    </button>
  </form>
  <div class="cloud-social">

    <div class="cloud-signed-in">
      <a href="https://console.developers.google.com/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Go to my console">Go to Cloud Console</a>
    </div>

  </div>

</div>

</div>

    </div>
  </div>
  <div id="maia-nav-x" class="maia-nav">
    <div class="maia-aux">
   <div class="cp-cta">
     <a class="cp-track maia-button maia-button-secondary white-button" href="/contact/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Contact Sales" data-g-label="Global Nav: Click" >Nous contacter</a>
     
       <a class="cp-track maia-button blue-button" href="https://console.developers.google.com?getstarted=https://cloud.google.com" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Try It Now" data-g-label="Global Nav: Click" style="color: #fff;">Essayer maintenant</a>
     
   </div>
      <ul>
        <li >
            <a href="/why-google/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Why Google">
            Pourquoi choisir Google
            </a>
        </li>
        <li  id="main-nav-product-dropdown" class="dropdown">
            <a href="/products/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Products">
            Produits
            </a>
        </li>
        <li >
            <a href="/solutions/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Solutions">
            Solutions
            </a>
        </li>
        <li >
            <a href="/customers/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Customers">
            Clients
            </a>
        </li>
        <li  id="main-nav-docs-dropdown" class="dropdown">
            <a href="/docs/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Documentation">
            Documentation
            </a>
        </li>
        <li >
            <a href="/support/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Support">
            Assistance
            </a>
        </li>
        <li >
            <a href="/partners/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Partners">
            Partners
            </a>
        </li>
         <li >
            <a href="http://googlecloudplatform.blogspot.com/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Blog">
            Blog
            </a>
        </li>
      </ul>
    </div>
  </div>

<!-- Products subnav -->
<div id="maia-nav-x" class="maia-nav products-nav">
  <div class="maia-aux">
    <div class="products-nav-dropdown maia-cols">

      <div id="compute-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Compute</span>
        <div class="dropdown-item-container">
          <a href="/compute/">
            <span class="product-name">Compute Engine</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/appengine/">
            <span class="product-name">App Engine</span>
          </a>
        </div>
      </div>

      <div id="storage-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Storage</span>
        <div class="dropdown-item-container">
          <a href="/sql/">
            <span class="product-name">Cloud SQL</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/storage/">
            <span class="product-name">Cloud Storage</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/datastore/">
            <span class="product-name">Cloud Datastore</span>
          </a>
        </div>
      </div>

      <div id="big-data-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Big Data</span>
        <div class="dropdown-item-container">
          <a href="/bigquery/">
            <span class="product-name">BigQuery</span>
          </a>
        </div>
      </div>

      <div id="services-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Services</span>
        <div class="dropdown-item-container">
          <a href="/dns/">
            <span class="product-name">Cloud DNS</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/endpoints/">
            <span class="product-name">Cloud Endpoints</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/translate/">
            <span class="product-name">Translate API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/prediction/">
            <span class="product-name">Prediction API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/pubsub/">
            <span class="product-name">Cloud Pub/Sub</span>
          </a>
        </div>
      </div>

      <div id="management-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Management</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/deployment-manager/">Cloud Deployment Manager</a></span>
        </div>
      </div>

      <div id="pricing-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Pricing</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/pricing/">Overview</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/calculator/">Calculator</a></span>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- Docs subnav -->
<div id="maia-nav-x" class="maia-nav products-docs-nav">
  <div class="maia-aux">
    <div class="products-nav-dropdown maia-cols">

      <div id="compute-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Compute</span>
        <div class="dropdown-item-container">
          <a href="/compute/docs">
            <span class="product-name">Compute Engine</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/appengine/docs">
            <span class="product-name">App Engine</span>
          </a>
        </div>
      </div>

      <div id="storage-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Storage</span>
        <div class="dropdown-item-container">
          <a href="/sql/docs">
            <span class="product-name">Cloud SQL</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/storage/docs">
            <span class="product-name">Cloud Storage</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/datastore/docs">
            <span class="product-name">Cloud Datastore</span>
          </a>
        </div>
      </div>

      <div id="big-data-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Big Data</span>
        <div class="dropdown-item-container">
          <a href="/bigquery/docs">
            <span class="product-name">BigQuery</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/hadoop/docs">
            <span class="product-name">Hadoop</span>
          </a>
        </div>
      </div>

      <div id="services-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Services</span>
        <div class="dropdown-item-container">
          <a href="/dns/docs">
            <span class="product-name">Cloud DNS</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/endpoints/docs">
            <span class="product-name">Cloud Endpoints</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/translate/">
            <span class="product-name">Translate API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/prediction/docs">
            <span class="product-name">Prediction API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/pubsub/docs">
            <span class="product-name">Cloud Pub/Sub</span>
          </a>
        </div>
      </div>

      <div id="management-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Management</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/deployment-manager/docs">Cloud Deployment Manager</a></span>
        </div>
      </div>

      <div id="pricing-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Tools</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/sdk/">Google Cloud SDK</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/mobile/">Android Studio</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="https://developers.google.com/eclipse/">Plugin for Eclipse</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/devtools/repo/cloud-repositories">Cloud Repositories (Git)</a></span>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- CONTENT_BEGIN -->

<!DOCTYPE html>
<html>
<head>
<title>Web Apps Articles &amp; Tutorials — Google Cloud Platform</title>
<meta name="description" content="Read technical articles about web applications and solutions with Google Cloud Platform, including auto scaling and how to manage complex applications in the cloud.">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/css/cp-ie.css'>
    <![endif]-->
<script src="/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Équilibrer la cohérence forte et la cohérence éventuelle avec Google&nbsp;Cloud&nbsp;Datastore</h1>
</div>
<div class="cp-article-tutorial">
<h2><a name="h.4n3hcboreol0" id="h.4n3hcboreol0"></a>Assurer une expérience utilisateur stable et tirer parti du modèle de cohérence dans le temps pour évoluer vers des ensembles de données volumineux</h2>
<p>Cet article explique comment obtenir une cohérence forte pour proposer une expérience utilisateur positive, tout en exploitant le modèle de cohérence dans le temps de Google&nbsp;Cloud&nbsp;Datastore pour gérer de grandes quantités de données et d'utilisateurs.</p>
<p>Cet article s'adresse aux ingénieurs et architectes logiciels désireux de développer des solutions sur Google&nbsp;Cloud&nbsp;Datastore. Pour aider les utilisateurs qui sont plus habitués aux bases de données relationnelles qu'aux systèmes non&nbsp;relationnels, tels que Google&nbsp;Cloud&nbsp;Datastore, il sera également fait allusion aux concepts analogues dans les bases de données relationnelles. Dans le présent document, nous partons du principe que vous connaissez les rudiments de Google&nbsp;Cloud&nbsp;Datastore. La méthode la plus simple pour commencer avec Google&nbsp;Cloud&nbsp;Datastore consiste à utiliser Google&nbsp;App&nbsp;Engine avec l'un des langages compatibles, à savoir Python, Java, Go ou PHP. Si vous n'avez jamais utilisé App&nbsp;Engine, vous êtes invité à lire le <a href="https://developers.google.com/appengine/">Guide de mise en route</a> et la section <a href="https://developers.google.com/appengine/docs/python/storage">Stockage de données</a> de l'un de ces langages. Bien que le langage Python soit utilisé pour les exemples de fragments de code, aucune compétence spécialisée dans ce domaine n'est requise pour suivre ce document.</p>
<h4>Sommaire</h4>
<p><a class="indnt" href="#h.w3kz4fze562t">NoSQL et cohérence dans le temps</a><br>
<a class="indnt" href="#h.tf76fya5nqk8">Cohérence dans le temps dans Google&nbsp;Cloud&nbsp;Datastore</a><br>
<a class="indnt" href="#h.3loc7ynqbw6i">Requête ascendante et groupe d'entités</a><br>
<a class="indnt" href="#h.ooaauy74mue8">Limitations des groupes d'entités et des requêtes ascendantes</a><br>
<a class="indnt" href="#h.k31yisins6ul">Alternatives aux requêtes ascendantes</a><br>
<a class="indnt" href="#h.buvz7spe7ytk">Obtention plus rapide d'une cohérence totale</a><br>
<a class="indnt" href="#h.njxgygqflg9k">Conclusion</a><br>
<a class="indnt" href="#h.ywh7cedcuhkk">Autres sources d'information</a></p>
<h2><a name="h.w3kz4fze562t" id="h.w3kz4fze562t"></a>NoSQL et cohérence dans le temps</h2>
<p>Depuis quelques années, les bases de données non&nbsp;relationnelles, connues également sous le nom de bases de données NoSQL, se posent comme une alternative crédible aux bases de données relationnelles. Google&nbsp;Cloud&nbsp;Datastore est l'une des bases de données non&nbsp;relationnelles les plus utilisées sur le marché. En 2013, Google&nbsp;Cloud&nbsp;Datastore a traité 4&nbsp;500&nbsp;milliards de transactions par mois (<a href="http://googlecloudplatform.blogspot.com/2013/05/reducing-app-engine-datastore-pricing-by-up-to-25-percent.html">article de blog Google&nbsp;Cloud&nbsp;Platform</a>). Cette solution permet aux développeurs de stocker des données et d'y accéder en toute simplicité. De par son caractère flexible, le schéma tend naturellement vers les langages de script et orientés objet. Google&nbsp;Cloud&nbsp;Datastore propose également plusieurs fonctionnalités que les bases de données relationnelles ne peuvent pas fournir de manière optimale, telles que des performances élevées à très grande échelle et une haute fiabilité.</p>
<p>Les développeurs davantage habitués aux bases de données relationnelles peuvent éprouver des difficultés à concevoir un système qui tire parti des bases de données non&nbsp;relationnelles, dans la mesure où certaines caractéristiques et pratiques inhérentes à ces dernières leur sont peut-être inconnues. Bien que Google&nbsp;Cloud&nbsp;Datastore propose un modèle de programmation simple, il est important de connaître ces caractéristiques. La cohérence dans le temps en fait partie et la programmation de cette cohérence est le thème central de cet article.</p>
<h3><a name="h.86naen3bqe0" id="h.86naen3bqe0"></a>En quoi consiste la cohérence dans le temps&nbsp;?</h3>
<p>La <span class="bld">cohérence dans le temps</span> est une garantie théorique selon laquelle, à condition qu'aucune nouvelle mise à jour ne soit apportée à une entité, toutes les lectures de l'entité renverront, au final, la dernière valeur mise à jour. Le service DNS (Domain&nbsp;Name&nbsp;System) Internet est un exemple bien connu de système présentant un modèle de cohérence dans le temps. Les serveurs DNS n'affichent pas nécessairement les valeurs les plus récentes, mais plutôt les valeurs mises en cache et répliquées dans de nombreux répertoires sur Internet. La réplication des valeurs modifiées sur l'ensemble des clients et serveurs DNS prend du temps. Cependant, DNS est un système très populaire qui est devenu l'un des piliers du réseau Internet. Son évolutivité élevée et son extrême évolutivité permettent d'effectuer des recherches de noms sur des centaines de millions d'appareils connectés à Internet.</p>
<p>La figure&nbsp;1 illustre le concept de réplication avec une cohérence dans le temps. Comme vous pouvez le voir sur le schéma, bien que des répliques soient toujours accessibles en lecture, il se peut que certaines d'entre elles soient incohérentes avec la dernière écriture sur le nœud d'origine, à un moment donné. Sur ce schéma, le nœud&nbsp;A est le nœud d'origine, tandis que les nœuds&nbsp;B et C sont des répliques.</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/eventual-consistency.png" alt="">
<figcaption>Figure&nbsp;1&nbsp;: Représentation conceptuelle de la réplication avec une cohérence dans le temps</figcaption>
</figure>
<p>Les bases de données relationnelles traditionnelles, au contraire, ont été conçues sur la base du concept de cohérence forte, désigné également sous le nom de cohérence immédiate. Cela signifie que toutes les données consultées immédiatement après une mise à jour seront cohérentes pour l'ensemble des observateurs de l'entité. Cette caractéristique a constitué un postulat de base pour de nombreux développeurs qui utilisent des bases de données relationnelles. Cependant, pour bénéficier d'une cohérence forte, les développeurs doivent trouver un compromis au niveau de l'évolutivité et des performances de leur application. Autrement dit, les données doivent être verrouillées au cours de la mise à jour ou de la réplication afin de s'assurer qu'aucun autre processus ne traite les mêmes données.</p>
<p>La figure&nbsp;2 illustre une vue conceptuelle de la topologie de déploiement et du processus de réplication avec une cohérence forte. Comme vous pouvez le voir sur ce schéma, les valeurs des répliques sont toujours cohérentes avec le nœud d'origine, mais elles ne sont pas accessibles tant que la mise à jour n'est pas terminée.</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/strong-consistency.png" alt="">
<figcaption>Figure&nbsp;2&nbsp;: Représentation conceptuelle de la réplication avec une cohérence forte</figcaption>
</figure>
<h3><a name="h.rcbsdmar23fq" id="h.rcbsdmar23fq"></a>Trouver le bon équilibre entre cohérence forte et cohérence dans le temps</h3>
<p>Au cours des dernières années, les bases de données non&nbsp;relationnelles n'ont cessé de gagner en popularité, notamment pour les applications Web qui nécessitent une évolutivité et des performances élevées avec une haute disponibilité. Ces bases de données permettent aux développeurs de choisir le parfait équilibre entre cohérence forte et cohérence dans le temps pour chaque application. Ils peuvent ainsi combiner les points forts de ces deux modèles. Par exemple, "savoir quels membres de votre liste d'amis sont en ligne à un moment donné" ou "savoir combien d'utilisateurs ont attribué +1 à votre message" sont des cas d'utilisation pour lesquels une cohérence forte n'est pas nécessaire. Vous pouvez alors tirer parti de la cohérence dans le temps pour garantir une évolutivité et des performances élevées. L'utilisation de la cohérence forte est nécessaire, par exemple, pour "déterminer si un utilisateur a terminé ou non le processus de facturation" ou pour connaître "le nombre de points empochés par un joueur au cours d'une bataille".</p>
<p>Pour généraliser les exemples ci-dessus, les scénarios dans lesquels de très nombreuses entités sont utilisées semblent généralement indiquer que la cohérence dans le temps est le modèle idéal. Si une requête renvoie un très grand nombre de résultats, il se peut que l'inclusion ou l'exclusion d'entités spécifiques n'ait aucune incidence sur l'expérience utilisateur. En revanche, les scénarios avec un petit nombre d'entités et un contexte étroit semblent indiquer qu'une cohérence forte est requise. Le confort d'utilisation s'en trouvera affecté, dans la mesure où le contexte indiquera aux utilisateurs les entités qui doivent être incluses ou exclues.</p>
<p>Pour toutes ces raisons, il est important que les développeurs comprennent les caractéristiques non&nbsp;relationnelles de Google&nbsp;Cloud&nbsp;Datastore. Dans les sections suivantes, nous examinerons comment combiner les modèles de cohérence dans le temps et de cohérence forte pour créer une application évolutive, à haute disponibilité et très performante, tout en conservant une expérience utilisateur stable.</p>
<h2><a name="h.tf76fya5nqk8" id="h.tf76fya5nqk8"></a>Cohérence dans le temps dans Google&nbsp;Cloud&nbsp;Datastore</h2>
<p>Il convient de sélectionner l'API appropriée lorsqu'une vue de données avec une cohérence forte est nécessaire. Le tableau&nbsp;1 illustre les différentes variétés d'API de requête Google&nbsp;Cloud&nbsp;Datastore, ainsi que les modèles de cohérence correspondants.</p>
<a href="#" name="73aa40d03f7c0cd78a8b69d986cc7d802f3e49eb" id="73aa40d03f7c0cd78a8b69d986cc7d802f3e49eb"></a><a href="#" name="2" id="2"></a>
<figure>
<table class="brdr-table" style="text-align:left;">
<tbody>
<tr>
<th>
<p>API Google&nbsp;Cloud&nbsp;Datastore</p>
</th>
<th>
<p>Lecture de la valeur d'entité</p>
</th>
<th>
<p>Lecture de l'index</p>
</th>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries">Requête globale</a></p>
</td>
<td>
<p>Cohérence dans le temps</p>
</td>
<td>
<p>Cohérence dans le temps</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Keys_only_queries">Requête globale "keys_only"</a></p>
</td>
<td>
<p>Sans objet</p>
</td>
<td>
<p>Cohérence dans le temps</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Ancestor_queries">Requête ascendante</a></p>
</td>
<td>
<p>Cohérence forte</p>
</td>
<td>
<p>Cohérence forte</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Retrieving_an_entity">Requête de recherche par clé</a> (méthode "get()")</p>
</td>
<td>
<p>Cohérence forte</p>
</td>
<td>
<p>Sans objet</p>
</td>
</tr>
</tbody>
</table>
<figcaption>Table&nbsp;1&nbsp;: Requêtes/Appels GET Google Cloud Datastore et modèles de cohérence possibles</figcaption>
</figure>
<p>Les requêtes Google&nbsp;Cloud&nbsp;Datastore sans ascendant sont connues sous le nom de <span class="bld">requêtes globales</span>. Elles sont conçues pour fonctionner avec un modèle de cohérence dans le temps. Cela ne garantit pas une cohérence forte. Une requête globale <span class="bld">keys-only</span> est une <span class="bld">requête globale</span> qui ne renvoie que les clés d'entités correspondant à la requête, et non les valeurs d'attribut des entités. Une <span class="bld">requête ascendante</span> couvre la requête sur la base d'une entité ascendante. Les sections suivantes décrivent chaque modèle de cohérence de manière plus détaillée.</p>
<h3><a name="h.cb1okox563r3" id="h.cb1okox563r3"></a>Cohérence dans le temps lors de la lecture de valeurs d'entité</h3>
<p>À l'exception des requêtes ascendantes, il se peut qu'une valeur d'entité mise à jour ne soit pas visible immédiatement lors de l'exécution d'une requête. Pour bien comprendre l'incidence de la cohérence dans le temps lors de la lecture de valeurs d'entité, "Joueur" possède une propriété "Score". Supposons, par exemple, que la valeur de la propriété "Score" initiale soit égale à 100. Après quelque temps, la valeur "Score" passe à 200. Si une requête globale est exécutée et que le résultat inclut la même entité "Joueur", il est possible que la valeur de la propriété "Score" de l'entité renvoyée soit inchangée (100).</p>
<p>Ce comportement est dû à la réplication entre les serveurs Google&nbsp;Cloud&nbsp;Datastore. La réplication est gérée par Bigtable et Megastore, les technologies sous-jacentes de Google&nbsp;Cloud &nbsp;Datastore (pour plus d'informations sur Bigtable et Megastore, reportez-vous à la section <a href="#h.ywh7cedcuhkk">Autres sources d'information</a>). La réplication est exécutée avec l'algorithme <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a>, lequel attend, de manière asynchrone, qu'une majorité des répliques aient accusé réception de la demande de mise à jour. La réplique est ensuite mise à jour avec les données de la demande après une certaine période. Il s'agit généralement d'une période assez courte, mais il n'y a aucune garantie quant à sa durée réelle. Il se peut qu'une requête lise les données non&nbsp;actualisées si elle est exécutée avant la fin de la mise à jour.</p>
<p>Dans la majorité des cas, la mise à jour atteint toutes les répliques très rapidement. Cependant, plusieurs facteurs, lorsqu'ils sont combinés, sont susceptibles d'allonger la période nécessaire pour obtenir une cohérence. Il s'agit notamment d'incidents à l'échelle d'un centre de données qui impliquent le basculement d'un grand nombre de serveurs entre les centres de données. Ces facteurs étant variables, il est impossible de spécifier formellement le temps nécessaire à l'établissement d'une cohérence complète.</p>
<p>En règle générale, une requête renvoie la dernière valeur dans un délai très court. Cependant, ce délai peut s'avérer beaucoup plus long dans les rares cas où la latence de réplication augmente. Les applications qui utilisent des requêtes Google&nbsp;Cloud&nbsp;Datastore globales doivent faire l'objet d'une conception soignée afin de tenir compte de ces cas de figure.</p>
<p>Il est possible d'éviter la cohérence dans le temps lors de la lecture de valeurs d'entité en utilisant une requête de type "keys-only", une requête ascendante ou une recherche par clé (méthode&nbsp;get()). Les différents types de requêtes feront l'objet d'une description plus détaillée ci-après.</p>
<h3><a name="h.4xdytk3hj44" id="h.4xdytk3hj44"></a>Cohérence dans le temps lors de la lecture d'un index</h3>
<p>Il se peut qu'un index n'ait pas encore été mis à jour lorsqu'une requête globale est exécutée. En d'autres termes, bien que vous soyez peut-être en mesure de lire les valeurs de propriété les plus récentes des entités, il se peut que la "liste des entités" incluse dans les résultats de la requête soit filtrée sur la base d'anciennes valeurs d'index.</p>
<p>Pour bien comprendre l'incidence de la cohérence dans le temps lors de la lecture d'un index, imaginez un scénario dans lequel une nouvelle entité "Joueur" est insérée dans Google&nbsp;Cloud&nbsp;Datastore. L'entité possède une propriété "Score" dont la valeur initiale est définie sur 300. Immédiatement après l'insertion, vous exécutez une requête "keys-only" pour récupérer toutes les entités dont la valeur "Score" est supérieure à 0. Vous vous attendez alors à ce que l'entité "Joueur" récemment insérée apparaisse dans les résultats de la requête. Cependant, elle n'apparaît pas. Cela peut se produire lorsque la table d'index de la propriété "Score" n'est pas mise à jour avec la nouvelle valeur insérée au moment de l'exécution de la requête.</p>
<p>Pour rappel, toutes les requêtes de Google&nbsp;Cloud&nbsp;Datastore sont exécutées par rapport à des <a href="https://developers.google.com/appengine/docs/python/datastore/indexes#Python_Index_definition_and_structure">tables d'index</a> et, pourtant, <a href="https://developers.google.com/appengine/articles/life_of_write">les mises à jour de ces tables sont asynchrones</a>. Chaque mise à jour d'entité se compose essentiellement de deux phases. Au cours de la première phase, qui est celle de validation, une écriture est effectuée dans le journal des transactions. Au cours de la deuxième phase, les données sont écrites et les index sont mis à jour. Si la phase de validation aboutit, la réussite de la phase d'écriture est également garantie, même si cela peut prendre un certain temps. Si vous interrogez une entité avant la mise à jour des index, il se peut que les données consultées ne soient pas encore cohérentes.</p>
<p>Compte tenu de ce processus en deux phases, les mises à jour les plus récentes des entités ne sont pas immédiatement visibles dans les requêtes globales. Comme c'est le cas pour la cohérence dans le temps de la valeur d'entité, le délai est généralement faible. Cependant, il peut atteindre quelques minutes, voire davantage, dans des circonstances exceptionnelles.</p>
<p>Cela peut également se produire après des mises à jour. Supposons, par exemple, que vous mettiez à jour une entité "Joueur" avec une nouvelle valeur de propriété "Score" de 0, et que vous exécutiez la même requête immédiatement après. Vous vous attendez, dans ce cas, à ce que l'entité n'apparaisse pas dans les résultats de la requête, car elle est exclue par la nouvelle valeur "Score" de 0. Cependant, compte tenu du comportement de mise à jour asynchrone identique à celui des index, il est possible que l'entité soit reprise dans les résultats.</p>
<p>Lors de la lecture d'un index, il n'est possible d'éviter la cohérence dans le temps qu'en utilisant une requête ascendante ou la méthode de recherche par clé. Ce comportement ne peut pas être évité avec une requête de type "keys-only".</p>
<h3><a name="h.ubkfi6o13a4f" id="h.ubkfi6o13a4f"></a>Cohérence forte lors de la lecture d'index et de valeurs d'entité</h3>
<p>Dans Google&nbsp;Cloud&nbsp;Datastore, deux API seulement fournissent une vue fortement cohérente pour la lecture d'index et de valeurs d'entité&nbsp;: (1) la méthode de recherche par clé et (2) la requête ascendante. Si la logique d'application exige une cohérence forte, le développeur doit utiliser l'une de ces méthodes pour lire des entités à partir de Google&nbsp;Cloud&nbsp;Datastore.</p>
<p>Google&nbsp;Cloud&nbsp;Datastore est un service conçu spécialement pour fournir une cohérence forte sur ces API. Lorsque l'une d'elles est appelée, Google&nbsp;Cloud&nbsp;Datastore efface toutes les mises à jour en attente sur l'une des répliques et des tables d'index, puis exécute la recherche ou la requête ascendante. Par conséquent, la dernière valeur d'entité, sur la base de la table d'index mise à jour, est toujours renvoyée avec des valeurs basées sur les mises à jour les plus récentes.</p>
<p>Contrairement aux requêtes, l'appel de recherche par clé ne renvoie qu'une seule entité ou un ensemble d'entités spécifié par une clé ou un jeu de clés. Cela signifie que la requête ascendante est le seul moyen disponible dans Google&nbsp;Cloud&nbsp;Datastore pour satisfaire aux exigences en matière de cohérence forte et de filtrage. Cependant, les requêtes ascendantes ne fonctionnent pas si aucun <span class="bld">groupe d'entités</span> n'est spécifié.</p>
<h2><a name="h.3loc7ynqbw6i" id="h.3loc7ynqbw6i"></a>Requête ascendante et groupe d'entités</h2>
<p>Comme indiqué au début de cet article, l'un des avantages de Google&nbsp;Cloud&nbsp;Datastore est de permettre aux développeurs de trouver un équilibre optimal entre une cohérence forte et une cohérence dans le temps. Dans Google&nbsp;Cloud&nbsp;Datastore, un <a href="https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency">groupe d'entités</a> est une unité qui se caractérise par une cohérence forte, par sa nature transactionnelle et par sa localité. En utilisant des groupes d'entités, les développeurs peuvent définir le champ d'application de la cohérence forte entre les entités d'une application. L'application peut ainsi maintenir la cohérence au sein du groupe d'entités, tout en garantissant une évolutivité, une disponibilité et des performances élevées en tant que système complet.</p>
<p>Un groupe d'entités est une hiérarchie formée par une entité racine et ses enfants ou descendants.<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup> Pour créer un groupe d'entités, un développeur définit un chemin ascendant qui se compose essentiellement d'une série de clés parent qui préfixent la clé enfant. La notion de groupe d'entités est illustrée à la figure&nbsp;3. Dans ce cas, l'entité racine avec la touche "ateam" a deux enfants, avec les touches "ateam/098745" et "ateam/098746".</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/croup-concept.png" alt="">
<figcaption>Figure&nbsp;3&nbsp;: Vue schématique de la notion de groupe d'entités</figcaption>
</figure>
<p>Les caractéristiques suivantes sont garanties à l'intérieur du groupe d'entités&nbsp;:</p>
<ul>
<li>Cohérence forte
<ul>
<li>Une requête ascendante exécutée sur le groupe d'entités renverra un résultat fortement cohérent. De cette manière, il affiche les valeurs d'entité les plus récentes, filtrées selon l'état d'index le plus récent.</li>
</ul>
</li>
<li>Transactionnalité
<ul>
<li>En délimitant une transaction de manière automatisée, le groupe fournit des caractéristiques&nbsp;ACID (atomicité, cohérence, isolation et durabilité) dans la transaction.</li>
</ul>
</li>
<li>Localité
<ul>
<li>Les entités d'un groupe sont stockées à des emplacements proches physiquement sur des serveurs Google&nbsp;Cloud&nbsp;Datastore, dans la mesure où toutes les entités sont triées et stockées selon l'ordre lexicographique des touches. Cela permet à une requête ascendante d'analyser plus rapidement le groupe d'entités avec un nombre minimum d'E/S.</li>
</ul>
</li>
</ul>
<p>Une requête ascendante est une forme particulière de requête qui s'exécute seulement par rapport à un groupe d'entités spécifié, avec une cohérence forte. En arrière-plan, Google&nbsp;Cloud&nbsp;Datastore vérifie que toutes les réplications et mises à jour d'index en attente sont appliquées avant d'exécuter la requête.</p>
<h3><a name="h.pyro8j6ki6tn" id="h.pyro8j6ki6tn"></a>Exemple de requête ascendante</h3>
<p>Cette section décrit l'utilisation pratique des groupes d'entités et des requêtes ascendantes. Dans l'exemple suivant, nous examinerons le problème de gestion des enregistrements de données pour des personnes. Supposons que vous ayez rédigé du code qui ajoute une entité d'un type spécifique, suivie immédiatement d'une requête réalisée sur ce type. Ce concept est illustré par l'exemple du code Python ci-dessous.</p>
<pre>
# Define the Person entity
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
    organization = db.StringProperty()
# Add a person and retrieve the list of all people
class MainPage(webapp2.RequestHandler):
    def post(self):
        person = Person(given_name='GI', surname='Joe', organization='ATeam')
        person.put()
        q = db.GqlQuery("SELECT * FROM Person")
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname,
                        'organization': p.organization})
</pre>
<p>Le problème avec ce code est que, dans la plupart des cas, la requête ne renvoie pas l'entité ajoutée dans la déclaration qui la précède. Puisque la requête figure dans la ligne qui vient immédiatement après l'insertion, l'index n'est pas mis à jour lors de l'exécution de la requête. Il existe également un problème avec la validité de ce scénario d'utilisation&nbsp;: Est-il vraiment nécessaire de renvoyer la liste de toutes les personnes sur une page sans contexte&nbsp;? Que faire s'il y a un million de personnes&nbsp;? Le renvoi de la page prendra bien trop de temps.</p>
<p>La nature de ce scénario d'utilisation suggère que vous deviez fournir un contexte pour affiner la requête. Dans cet exemple, le contexte utilisé sera l'organisation. De ce fait, vous pourrez utiliser l'organisation comme un groupe d'entités et exécuter une requête ascendante, et remédier ainsi au problème de cohérence. Cela est illustré par le code Python ci-dessous.</p>
<pre>
class Organization(db.Model):
    name = db.StringProperty()
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
class MainPage(webapp2.RequestHandler):
    def post(self):
        org = Organization.get_or_insert('ateam', name='ATeam')
        person = Person(parent=org)
        person.given_name='GI'
        person.surname='Joe'
        person.put()
        q = db.GqlQuery("SELECT * FROM Person WHERE ANCESTOR IS :1 ", org)
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname})
</pre>
<p>Cette fois, avec l'ancêtre "org" spécifié dans GqlQuery, la requête renvoie l'entité qui vient d'être insérée. L'exemple peut être étendu pour afficher le détail d'une seule personne en exécutant, sur son nom, une requête contenant l'ancêtre. Une autre méthode consiste à enregistrer la clé d'entité et à l'utiliser ensuite pour afficher le détail avec une méthode de recherche par clé.</p>
<h3><a name="h.l10xxpfjg70q" id="h.l10xxpfjg70q"></a>Maintenir la cohérence entre Memcache et Google&nbsp;Cloud&nbsp;Datastore</h3>
<p>Les groupes d'entités peuvent également être utilisés pour maintenir la cohérence entre des entrées Memcache et des entités Google&nbsp;Cloud&nbsp;Datastore. Supposons, par exemple, que vous deviez compter le nombre de personnes dans chaque équipe et les stocker dans Memcache. Pour être sûr que les données mises en cache sont cohérentes avec les valeurs les plus récentes de Google&nbsp;Cloud&nbsp;Datastore, vous pouvez utiliser des <a href="https://developers.google.com/appengine/docs/python/datastore/metadataqueries#Python_Entity_group_metadata">métadonnées de groupe d'entités</a>. Ces métadonnées renvoient le dernier numéro de version du groupe d'entités spécifié. Vous pouvez comparer le numéro de version avec celui stocké dans Memcache. Cette méthode vous permet de détecter un changement dans l'une des entités du groupe en effectuant une lecture dans un ensemble de métadonnées, au lieu d'analyser toutes les entités individuelles du groupe.</p>
<h2><a name="h.ooaauy74mue8" id="h.ooaauy74mue8"></a>Limitations des groupes d'entités et des requêtes ascendantes</h2>
<p>L'utilisation de groupes d'entités et de requêtes ascendantes n'est pas la solution miracle. Dans la pratique, deux éléments rendent l'application de cette technique assez difficile&nbsp;:</p>
<ol class="c28 lst-kix_qyusimaqza9q-0 start" start="1">
<li>Une seule mise à jour par seconde d'écriture est autorisée pour chaque groupe d'entités.</li>
<li>La relation du groupe d'entités ne peut pas être modifiée après la création de l'entité.</li>
</ol>
<h3><a name="h.8yrg89iapdjp" id="h.8yrg89iapdjp"></a>Limite en écriture</h3>
<p>Le fait que le système doive être conçu pour contenir le nombre de mises à jour (ou de transactions) dans chaque groupe d'entités constitue une difficulté majeure. La limite est fixée à une mise à jour par seconde et par groupe d'entités.<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup> Si le nombre de mises à jour doit dépasser cette limite, il se peut que le groupe d'entités bride les performances.</p>
<p>Dans l'exemple ci-dessus, il se peut que chaque organisation doive mettre à jour le dossier de l'un de ses membres. Imaginons un scénario dans lequel l'organisation "ateam" compte 1&nbsp;000&nbsp;personnes et où chacune d'elles peut faire l'objet d'une mise à jour par seconde sur n'importe quelle propriété. Par conséquent, il peut y avoir jusqu'à 1&nbsp;000&nbsp;mises à jour par seconde dans le groupe d'entités, un résultat qui ne serait pas réalisable en raison de la limite de mises à jour. Cela illustre à quel point il est important de choisir une conception de groupe d'entités appropriée, qui tienne compte des exigences en termes de performances. Il s'agit là de l'une des difficultés pour trouver l'équilibre optimal entre la cohérence dans le temps et la cohérence forte.</p>
<h3><a name="h.slap2zz3i3rk" id="h.slap2zz3i3rk"></a>Immuabilité des relations de groupes d'entités</h3>
<p>Une deuxième difficulté réside dans l'immuabilité des relations de groupes d'entités. Une relation de ce type est formée de manière statique sur la base du nommage des clés. Une fois l'entité créée, la relation ne peut plus être modifiée. La seule option disponible pour la modifier consiste à supprimer les entités d'un groupe, puis à les recréer. Cette difficulté nous empêche d'utiliser des groupes d'entités pour définir, de manière dynamique, des étendues ad&nbsp;hoc à des fins de cohérence ou de transactionnalité. Au contraire, le champ d'application de la transactionnalité et la cohérence sont étroitement liés au groupe d'entités statique défini au moment de la conception.</p>
<p>Prenons, comme exemple, un scénario dans lequel vous souhaitez établir un virement électronique entre deux comptes bancaires. Ce scénario commercial nécessite une cohérence forte et une transactionnalité. Cependant, les deux comptes ne peuvent pas être rassemblés en un seul groupe d'entités en dernière minute ni être basés sur un parent global. Ce groupe d'entités créerait, en effet, un goulot d'étranglement pour l'ensemble du système, empêchant de ce fait l'exécution d'autres demandes de virement. Les groupes d'entités ne peuvent donc pas être utilisés de cette façon.</p>
<p>Il existe toutefois une autre solution pour mettre en œuvre un virement électronique en bénéficiant d'une évolutivité et d'une disponibilité élevées. Une solution consiste à utiliser des <a href="https://developers.google.com/appengine/docs/python/datastore/#Python_Cross_group_transactions">transactions entre différents groupes d'entité (XG)</a>, pour la transactionnalité, et la méthode "recherche par clé" de Google&nbsp;Cloud&nbsp;Datastore ou une requête ascendante, pour la cohérence. Les transactions entre différents groupes d'entité sont une fonctionnalité Google&nbsp;Cloud&nbsp;Datastore qui permet de bénéficier de caractéristiques ACID pour cinq entités ou groupes d'entités au sein d'une transaction. L'utilisation de ces transactions vous permet de former un champ de transaction de manière dynamique avec les deux comptes bancaires au moment du traitement de la demande.</p>
<p>N'oubliez pas que les transactions XG garantissent uniquement la transactionnalité. Pour garantir une cohérence forte lors de la lecture des deux comptes bancaires, vous devez utiliser la méthode de recherche par clé ou une requête ascendante. Une erreur est renvoyée si vous essayez d'exécuter une requête qui n'est pas de type ascendant au sein d'une transaction.</p>
<h2><a name="h.k31yisins6ul" id="h.k31yisins6ul"></a>Alternatives aux requêtes ascendantes</h2>
<p>Si vous avez déjà créé une application avec un grand nombre d'entités stockées dans Google&nbsp;Cloud&nbsp;Datastore, il peur s'avérer difficile d'intégrer, par la suite, des groupes d'entités au cours d'une opération de refactorisation. Vous devriez, en effet, supprimer toutes les entités et les ajouter au sein d'une relation de groupe d'entités. C'est pourquoi, s'agissant de la modélisation des données pour Google&nbsp;Cloud&nbsp;Datastore, il est important de prendre une décision quant à la conception du groupe d'entités dès le début du processus de conception de l'application. Dans le cas contraire, vous risquez d'être limité au niveau de la prise en compte d'autres solutions pour obtenir un certain niveau de cohérence, comme une requête "keys-only" ("clés uniquement") suivie d'une requête de recherche par clé, ou l'utilisation de Memcache.</p>
<h3><a name="h.56geqhlrqja4" id="h.56geqhlrqja4"></a>Requête globale "keys-only" suivie d'une recherche par clé</h3>
<p>Une requête globale "keys-only" est un type de requête spécial qui renvoie seulement des clés, sans les valeurs de propriété des entités. Étant donné que les valeurs renvoyées sont exclusivement des clés, la requête ne porte pas sur une valeur d'entité susceptible de comporter un problème de cohérence. La combinaison formée d'une requête globale "keys-only" et de la méthode de recherche lira les valeurs d'entité les plus récentes. Il convient toutefois de noter que l'utilisation d'une requête "keys_only" n'exclut pas la possibilité qu'un index ne soit pas encore cohérent au moment de la requête. Cela peut se traduire par l'exclusion d'une entité dans les résultats de recherche. Le résultat de la requête peut éventuellement être généré sur la base de l'exclusion des anciennes valeurs d'index. En résumé, un développeur ne peut utiliser une requête globale "keys-only", suivie d'une recherche par clé, que si l'application accepte que la valeur d'index ne soit pas encore cohérente au moment de l'exécution d'une requête.</p>
<h3><a name="h.kzvtug7i4vlw" id="h.kzvtug7i4vlw"></a>Utilisation de Memcache</h3>
<p>Le service Memcache est volatil, mais offre une cohérence très forte. Aussi, en associant des recherches Memcache à des requêtes Google&nbsp;Cloud&nbsp;Datastore, il est possible de développer un système qui, dans la majorité des cas, atténuera les problèmes de cohérence.</p>
<p>Prenons l'exemple d'un jeu qui gère une liste dans laquelle chaque entité "Joueur" a un score supérieur à zéro.</p>
<ul>
<li>Dans les cas des demandes d'insertion ou de mise à jour, appliquez-les à la liste d'entités "Joueur" dans Memcache, ainsi qu'à Google&nbsp;Cloud&nbsp;Datastore.</li>
<li>Dans le cas des demandes de requête, lisez la liste d'entités "Joueur" depuis Memcache et exécutez une requête "keys-only" sur Google&nbsp;Cloud&nbsp;Datastore si la liste n'est pas présente dans Memcache.</li>
</ul>
<p>La liste renvoyée est cohérente dès lors que la liste mise en cache est présente dans Memcache. Si l'entrée a été expulsée, ou si le service Memcache est temporairement indisponible, il se peut que le système doive lire la valeur d'une requête Google&nbsp;Cloud&nbsp;Datastore susceptible de renvoyer un résultat incohérent. Cette technique peut être appliquée à toute application qui tolère un faible degré d'incohérence.</p>
<p>Plusieurs bonnes pratiques peuvent être suivies lorsque vous utilisez Memcache comme couche de mise en cache pour Google&nbsp;Cloud&nbsp;Datastore&nbsp;:</p>
<ul>
<li>Identifiez les exceptions et les erreurs Memcache afin de maintenir la cohérence entre la valeur Memcache et la valeur Google&nbsp;Cloud&nbsp;Datastore. Si une exception est renvoyée lors de la mise à jour de l'entrée sur Memcache, prenez soin d'invalider l'ancienne entrée dans Memcache. Autrement, il risque d'y avoir des valeurs différentes pour une même entité (une ancienne valeur dans Memcache et une nouvelle dans Google&nbsp;Cloud&nbsp;Datastore).</li>
<li>Définissez une <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_How_cached_data_expires">période d'expiration</a> sur les entrées Memcache. Il est conseillé de définir des périodes courtes pour l'expiration de chaque entrée, afin de réduire le risque d'incohérence dans le cas des exceptions Memcache.</li>
<li>Utilisez la fonctionnalité <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_Using_compare_and_set_in_Python">compare-and-set</a> lors de la mise à jour des entrées pour un contrôle de simultanéité. Vous éviterez ainsi tout risque de perturbation entre les mises à jour simultanées portant sur la même entrée.</li>
</ul>
<h3><a name="h.ooddikjhrygc" id="h.ooddikjhrygc"></a>Migration progressive vers les groupes d'entités</h3>
<p>Les suggestions énoncées dans la section précédente n'éliminent pas complètement la possibilité d'un comportement incohérent. Il est préférable de concevoir l'application sur la base de groupes d'entités et de requêtes ascendantes lorsqu'une cohérence forte est nécessaire. Cependant, il peut s'avérer impossible de faire migrer une application, ce qui peut signifier l'adoption d'une logique d'application et de requêtes ascendantes au détriment de requêtes globales pour un modèle de données. Pour y parvenir, une solution consiste à mettre en place un processus de transition progressif, tel que celui exposé ci-dessous&nbsp;:</p>
<ol class="c28 lst-kix_gkyism9dw6ma-0 start" start="1">
<li>Identifiez et classez par priorité les fonctions de l'application qui nécessitent une cohérence forte.</li>
<li>Élaborez une nouvelle logique pour les fonctions "insert()" ou "update()" à l'aide de groupes d'entités, en plus (plutôt qu'en remplacement) de la logique en place. De cette manière, toute nouvelle insertion ou mise à jour sur des nouveaux groupes d'entités et d'anciennes entités pourra être traitée par une fonction appropriée.</li>
<li>Modifiez la logique déjà créée pour les fonctions de lecture ou de requête. Les requêtes ascendantes sont exécutées en premier s'il existe un nouveau groupe d'entités pour la demande. Exécutez l'ancienne requête globale comme logique de secours si le groupe d'entités n'existe pas.</li>
</ol>
<p>Cette stratégie permet de migrer progressivement d'un modèle de données déjà créé vers un nouveau modèle basé sur des groupes d'entités, ce qui réduit le risque de problèmes causés par une cohérence dans le temps. Dans la pratique, cette méthode dépend de scénarios d'utilisation et d'exigences spécifiques pour être appliquée à un système réel.</p>
<h3><a name="h.gj5afnup3sr9" id="h.gj5afnup3sr9"></a>Repli sur le mode dégradé</h3>
<p>Pour l'heure, il est difficile de détecter, de manière automatisée, une situation dans laquelle la cohérence d'une application s'est dégradée. Cependant, cela peut s'avérer possible dans certains cas&nbsp;; en contrôlant les demandes d'assistance des clients, par exemple. Si tel est le cas, vous avez la possibilité de mettre en œuvre un mode dégradé pouvant être activé ou désactivé afin de désactiver certaines zones de la logique d'application qui nécessitent une cohérence forte. Par exemple, plutôt que présenter un résultat de requête incohérent sur un écran de rapport de facturation, un message de maintenance peut être affiché pour cet écran. Ce faisant, les autres services de l'application peuvent continuer à diffuser, atténuant ainsi l'impact sur le confort d'utilisation.</p>
<h2><a name="h.buvz7spe7ytk" id="h.buvz7spe7ytk"></a>Obtention plus rapide d'une cohérence totale</h2>
<p>Dans une application de grande envergure qui compte des millions d'utilisateurs ou plusieurs téraoctets d'entités Google&nbsp;Cloud&nbsp;Datastore, il est possible qu'une utilisation inadaptée de Google&nbsp;Cloud&nbsp;Datastore conduise à une dégradation de la cohérence. Voici quelques exemples&nbsp;:</p>
<ul>
<li>Numérotation séquentielle des clés d'entité</li>
<li>Trop d'index</li>
</ul>
<p>Ces pratiques n'affectent pas les petites applications. Cependant, plus la taille de l'application augmente, plus ces pratiques risquent d'allonger le temps nécessaire pour mettre en place la cohérence. Il est donc préférable de les éviter au cours des premières étapes de la conception de l'application.</p>
<h3><a name="h.rwk0fv57jze5" id="h.rwk0fv57jze5"></a>Anti-patron n°&nbsp;1&nbsp;: Numérotation séquentielle des clés d'entité</h3>
<p>Avant la sortie d'App&nbsp;Engine&nbsp;SDK&nbsp;1.8.1, Google&nbsp;Cloud&nbsp;Datastore utilisait une suite de petits identifiants entiers avec des modèles généralement consécutifs comme noms de clé par défaut générés automatiquement. Dans certains articles, cette technique est désignée sous le nom de "règle héritée" pour créer des entités auxquelles aucun nom de clé n'est spécifié par l'application. Cette règle générait des noms de clés d'entité avec une numérotation séquentielle comme 1000, 1001, 1002, etc. Cependant, comme nous l'avons vu plus haut, Google&nbsp;Cloud&nbsp;Datastore stocke les entités par ordre lexicographique des noms de clés. Il y a donc de fortes chances que ces entités soient stockées sur les mêmes serveurs Google&nbsp;Cloud&nbsp;Datastore. Si une application attire un très large public, cette numérotation séquentielle peut entraîner une concentration d'opérations sur un serveur spécifique, ce qui peut se traduire par une latence plus importante pour la cohérence.</p>
<p>Avec App&nbsp;Engine&nbsp;SDK&nbsp;1.8.1, Google&nbsp;Cloud&nbsp;Datastore s'enrichit d'une nouvelle méthode de numérotation des identifiants avec une règle par défaut qui utilise des identifiants "dispersés" (voir la documentation de <a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Assigning_identifiers">référence</a>). Cette règle génère une séquence aléatoire d'identifiants pouvant comporter jusqu'à 16&nbsp;chiffres répartis de manière approximativement uniforme. L'utilisation de cette règle devrait améliorer la répartition du trafic de l'application de grande envergure entre divers serveurs Google&nbsp;Cloud&nbsp;Datastore, permettant ainsi de parvenir plus rapidement à la cohérence. La règle par défaut est recommandée, sauf si votre application nécessite expressément une compatibilité avec la règle héritée.</p>
<p>Si vous définissez explicitement des noms de clés sur les entités, il convient de concevoir le schéma de nommage de façon à accéder aux entités de manière uniforme sur l'ensemble de l'espace de nommage des clés. En d'autres termes, ne concentrez pas l'accès dans une plage spécifique, car les entités sont classées selon l'ordre lexicographique des noms de clés. Dans le cas contraire, il se peut que vous soyez confronté au même problème qu'avec la numérotation séquentielle.</p>
<p>Pour illustrer la répartition inégale de l'accès sur l'espace de clés, prenons un exemple dans lequel des entités sont créées avec des noms de clés séquentiels, comme indiqué dans le code suivant&nbsp;:</p>
<pre>
p1 = Person(key_name='0001')
p2 = Person(key_name='0002')
p3 = Person(key_name='0003')
...
</pre>
<p>Le format d'accès de l'application risque de créer un "point chaud" sur une certaine plage des noms de clés, comme si l'accès avait été concentré sur les entités "Personne" récemment créées. Dans ce cas, les clés fréquemment utilisées auront toutes des identifiants plus élevés. Il se peut alors que la charge soit concentrée sur un serveur Google&nbsp;Cloud&nbsp;Datastore spécifique.</p>
<p>Pour comprendre le concept de répartition uniforme sur l'espace de clés, vous pouvez également envisager d'utiliser de longues chaînes aléatoires pour les noms de clés. Vous en trouverez l'illustration dans l'exemple suivant&nbsp;:</p>
<pre>
p1 = Person(key_name='t9P776g5kAecChuKW4JKCnh44uRvBDhU')
p2 = Person(key_name='hCdVjL2jCzLqRnPdNNcPCAN8Rinug9kq')
p3 = Person(key_name='PaV9fsXCdra7zCMkt7UX3THvFmu6xsUd')
...
</pre>
<p>Désormais, les entités "Personne" récemment créées seront dispersées sur l'espace de clés et sur plusieurs serveurs. Cela suppose qu'il y ait suffisamment d'entités "Personne".</p>
<h3><a name="h.ou9y4doeg7dm" id="h.ou9y4doeg7dm"></a>Anti-patron n°&nbsp;2&nbsp;: Trop d'index</h3>
<p>Dans Google&nbsp;Cloud&nbsp;Datastore, une mise à jour effectuée sur une entité entraînera la mise à jour de tous les index définis pour ce type d'entité. Pour en savoir plus, reportez-vous à la section <a href="https://developers.google.com/appengine/articles/life_of_write">Life of a Datastore Write</a>) (en anglais). Si de nombreux index personnalisés sont utilisés dans une application, une mise à jour peut impliquer des dizaines, des centaines, voire des milliers de mises à jour sur les tables d'index. Dans une application de grande envergure, une utilisation excessive d'index personnalisés peut entraîner une charge accrue sur le serveur et risque d'allonger le délai nécessaire pour appliquer la cohérence.</p>
<p>Dans la plupart des cas, les index personnalisés sont ajoutés pour répondre à des besoins tels que des tâches d'analyse des données, de dépannage ou d'assistance clientèle. Google <a href="/bigquery/">BigQuery</a> est un moteur de requête massivement évolutif, capable d'exécuter des requêtes ad&nbsp;hoc sur de vastes ensembles de données sans index prédéfinis. Cet outil est mieux adapté que Google&nbsp;Cloud&nbsp;Datastore aux scénarios d'assistance clientèle, de dépannage ou d'analyse de données qui nécessitent des requêtes complexes.</p>
<p>Une méthode consiste à combiner Google&nbsp;Cloud&nbsp;Datastore et BigQuery afin de répondre à différentes exigences commerciales. Vous pouvez utiliser Google&nbsp;Cloud&nbsp;Datastore pour le traitement transactionnel en ligne (OLTP, Online transaction processing) requis pour la logique d'application de base et Google&nbsp;BigQuery pour le traitement analytique en ligne (OLAP, Online analytical processing) nécessaire aux opérations de backend. Il peut s'avérer nécessaire de mettre en œuvre un flux d'exportation des données en continu de Google&nbsp;Cloud&nbsp;Datastore vers BigQuery afin de déplacer les données nécessaires pour ces requêtes.</p>
<p>Outre une mise en œuvre différente pour ces index personnalisés, une autre recommandation concerne la définition explicite de propriétés non&nbsp;indexées (reportez-vous à la section <a href="https://developers.google.com/appengine/docs/python/ndb/properties#options">Options de propriété</a> dans la documentation de référence). Par défaut, Google&nbsp;Cloud&nbsp;Datastore permet de créer une table d'index différente pour chaque propriété indexable d'un type d'entité. S'il existe 100&nbsp;propriétés pour un type, il y aura 100&nbsp;tables d'index pour ce type, et 100&nbsp;autres mises à jour pour chaque mise à jour d'une entité. Une bonne pratique consiste alors à définir des propriétés non&nbsp;indexées, lorsque cela s'avère possible, si elles ne sont pas nécessaires pour une condition de requête.</p>
<p>Outre le fait qu'elles réduisent les risques de latence accrue pour parvenir à la cohérence, ces optimisations d'index peuvent entraîner une réduction sensible des coûts de Google&nbsp;Cloud&nbsp;Datastore dans une application de grande envergure qui fait une utilisation intensive d'index.</p>
<h2><a name="h.njxgygqflg9k" id="h.njxgygqflg9k"></a>Conclusion</h2>
<p>La cohérence dans le temps est une composante essentielle des bases de données non&nbsp;relationnelles. Elle permet aux développeurs de trouver l'équilibre idéal entre l'évolutivité, les performances et la cohérence. Il est essentiel de comprendre comment gérer l'équilibre entre la cohérence dans le temps et la cohérence forte pour concevoir un modèle de données optimal pour votre application. Dans Google&nbsp;Cloud&nbsp;Datastore, l'utilisation de groupes d'entités et de requêtes ascendantes constitue le meilleur moyen de garantir une cohérence forte sur un périmètre d'entités. Si l'intégration de groupes d'entités s'avère impossible dans votre application en raison des limitations décrites précédemment, vous pouvez envisager d'autres options, telles que l'aide des requêtes "keys-only" ou encore Memcache. Dans le cas des applications de grande envergure, il est conseillé d'adopter des bonnes pratiques, telles que l'utilisation d'identifiants dispersés et l'indexation réduite, afin d'accélérer la mise en œuvre de la cohérence. Il peut également s'avérer judicieux d'associer Google&nbsp;Cloud&nbsp;Datastore à BigQuery pour répondre aux exigences commerciales portant sur des requêtes complexes et réduire, dans la mesure du possible, l'utilisation d'index Google&nbsp;Cloud&nbsp;Datastore.</p>
<h2><a name="h.ywh7cedcuhkk" id="h.ywh7cedcuhkk"></a>Autres sources d'information</h2>
<p>Vous trouverez, dans les sources d'information ci-dessous, davantage de renseignements sur les sujets traités dans cet article&nbsp;:</p>
<ul>
<li><a href="https://developers.google.com/appengine/docs/python/datastore/">Google&nbsp;App&nbsp;Engine&nbsp;: stockage de données</a></li>
<li><a href="https://developers.google.com/appengine/articles/datastore/overview">Comprendre le magasin de données (série)</a></li>
<li><a href="http://googlecloudplatform.blogspot.com/">Blog de Google&nbsp;Cloud&nbsp;Platform</a></li>
<li><a href="https://developers.google.com/cloud-sql/">Google&nbsp;Cloud&nbsp;SQL</a></li>
<li><a href="https://developers.google.com/appengine/training/cloud-sql/">Utilisation de Python&nbsp;App&nbsp;Engine avec Google&nbsp;Cloud&nbsp;SQL</a></li>
<li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/bigtable-osdi06.pdf">Bigtable&nbsp;: Système de stockage distribué pour les données structurées</a></li>
<li><a href="http://googleappengine.blogspot.com/2011/07/app-engine-152-sdk-released.html">App&nbsp;Engine&nbsp;1.5.2&nbsp;SDK disponible</a></li>
<li><a href="http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper32.pdf">Megastore&nbsp;: Stockage évolutif et à haute disponibilité pour les services interactifs</a></li>
</ul>
<br>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> Il est même possible de former un groupe d'entités en n'indiquant qu'une seule clé de l'entité racine ou parent, sans stocker les entités proprement dites de la racine ou du parent, étant donné que les fonctions du groupe d'entités sont toutes mises en œuvre sur la base des relations entre les clés.</p>
<p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> La limite est fixée à une mise à jour par seconde et par groupe d'entités, en dehors des transactions, ou à une transaction par seconde et par groupe d'entités. Si vous regroupez plusieurs mises à jour dans une même transaction, vous êtes limité à une taille de transaction maximale de 10&nbsp;Mo et à la vitesse d'écriture maximale du serveur Datastore.</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">Commentaires sur ce document</a><br>
<br></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'fr',
        'region': 'emea',
        'language': 'fr'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>

<!-- CONTENT_END -->

  <!-- Scripts to include both on Goro + Devsite -->
  <script type="text/javascript">
   window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
  </script>

  <!-- GTM implementation -->

  <!-- Start dataLayer -->
    <script>
      dataLayer = [{
        'country': '',
        'region': '',
        'language': 'fr'
      }];
    </script>
  <!-- End dataLayer -->

  <!-- Start Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');</script>
  <!-- End Google Tag Manager -->

  <!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro -->
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular-sanitize.js"></script>

  <script src="/js/base.min.js"></script>

<!-- Secondary right-side scroll-nav -->
<script>
  new lfl.ui.ScrollNav({});
  new lfl.cloud.GlobalProductMenu();
  new lfl.cloud.GlobalNavDocsSubMenu();
</script>

<script>new cloud.SocialFeeds(document.getElementById('feeds'));</script>



  <div id="maia-signature"></div>
  <div id="maia-footer">

    <!-- maia-footer-local -->
    <div id="maia-footer-local">
      <div class="maia-aux">

          <div class="ent-footer-top">
  <div class="g-plus-wrapper">
    <div class="g-plusone" data-href="https://cloud.google.com/"></div>
  </div>
  <div class="g-plus-link"><a href="https://plus.sandbox.google.com/+googlecloudplatform/posts" rel="publisher">Google+</a></div>
  <div class="search">
    <form onsumbit="return false;" class="maia-search" action="/search">
    <input name="q" placeholder="Search this site" type="text">
    <input name="hl" type="hidden" value="">
    <input name="q" type="hidden" value="site:cloud.google.com/">
    <button class="maia-button" event="autotrack-data-g" data-g-event="Footer" data-g-action="Site Search" data-g-label="Submit">
      <span class="maia-search-icon">Search</span>
    </button>
    </form>
  </div>

</div>

<div class="ent-footer-links">
  <div class="ent-footer-unit">
    <h4><a href="/why-google/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Why Google">Why Google</a></h4>
    <ul>
      <li><a href="/why-google/#infrastructure" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Infrastructure">Infrastructure</a></li>
      <li><a href="/why-google/#product" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Product">Product</a></li>
      <li><a href="/why-google/#services" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Services">Services</a></li>
      <li><a href="/why-google/#scalability" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Scalability">Scalability</a></li>
      <li><a href="/why-google/#performance" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Performance">Performance</a></li>
      <li><a href="/why-google/#support" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Support">Support</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/products/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Products">Products</a></h4>
    <ul>
      <li><a href="/appengine/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="App Engine">App Engine</a></li>
      <li><a href="/compute/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Compute Engine">Compute Engine</a></li>
      <li><a href="/storage/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Storage">Cloud Storage</a></li>
      <li><a href="/sql/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud SQL">Cloud SQL</a></li>
      <li><a href="/datastore/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Datastore">Cloud Datastore</a></li>
      <li><a href="/bigquery/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="BigQuery">BigQuery</a></li>
      <li><a href="/prediction/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Prediction API">Prediction API</a></li>
      <li><a href="/translate/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Translate API">Translate API</a></li>
      <li><a href="/endpoints/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Endpoints">Cloud Endpoints</a></li>
      <li><a href="/products/calculator/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing Calculator">Pricing Calculator</a></li>
      <li><a href="/pricing/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing">Pricing</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/solutions/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Solutions">Solutions</a></h4>
    <ul>
      <li><a href="/solutions/mobile/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Mobile">Mobile</a></li>
      <li><a href="/solutions/gaming/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Gaming">Gaming</a></li>
      <li><a href="/solutions/hadoop/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Hadoop">Hadoop</a></li>
      <li><a href="/solutions/mongodb/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="mongodb">MongoDB</a></li>
      <li><a href="/solutions/rabbitmq/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="rabbitmq">RabbitMQ</a></li>
      <li><a href="/solutions/cassandra/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="cassandra">Cassandra</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/customers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Customers" data-g-label="Customers">Customers</a></h4>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/developers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Developers">Developers</a></h4>
    <ul>
      <li><a href="/developers/#documentation" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Documentation">Documentation</a></li>
      <li><a href="/developers/#resources" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Resources">Resources</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/support/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Support">Support</a></h4>
    <ul>
      <li><a href="https://support.google.com/cloud/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Platform Support Help Center">Platform Support Help Center</a></li>
      <li><a href="https://support.google.com/cloudbilling/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Billing Help Center">Billing Help Center</a></li>
      <li><a href="https://enterprise.google.com/supportcenter/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google for Work Support Center">Google for Work Support Center</a></li>
    </ul>

  </div>


  <div class="ent-footer-unit">
    <h4><a href="/partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Partners">Partners</a></h4>
    <ul>
      <li><a href="/partners/technology-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Technology Partner">Technology Partners</a></li>
      <li><a href="/partners/service-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Service Partner">Service Partners</a></li>
    </ul>
  </div>

  </div>
  <br class="clear" />

  </div>
  </div>
    <!-- /maia-footer-local -->

    <!-- maia-footer-global -->
    <div id="maia-footer-global">
      <div class="maia-locales">
        <select name="language" 
        onchange="var lang=this[this.selectedIndex].value;if(lang!='')
        {window.location.href=window.location.pathname + '?hl=' + lang};">>
          <option value="en" >English</option>
          <option value="fr" selected>Français</option>
          <option value="de" >Deutsch</option>
          <option value="ja" >日本語</option>
          <option value="ko" >한국어</option>
          <option value="pt-br" >Português</option>
          <option value="es" >Español</option>
          <option value="zh-tw" >中文（繁體中文）</option>
        </select>
      </div>
      <div class="maia-aux">
        <ul>
          <li><a href="http://www.google.com/">Google</a></li>
          <li><a href="https://developers.google.com/readme/terms">Terms of Service</a></li>
          <li><a href="https://www.google.com/intl/fr/policies/privacy/">Privacy Policy</a></li>
        </ul>
      </div>
    </div>
  </div>
  <!-- /maia-footer-global -->
  <script src="//www.google.com/js/maia.js"></script>
  <script type="text/javascript" async defer src="//www.gstatic.com/feedback/api.js"></script>
  <script id="jqueryui" src="//ajax.googleapis.com/ajax/libs/jqueryui/1.8.10/jquery-ui.min.js"></script>
  </body>
</html>
