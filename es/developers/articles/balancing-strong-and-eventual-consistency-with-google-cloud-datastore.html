<!DOCTYPE html>
<html lang="es" class="maia">
  <head>
    <title>Cloud Computing &amp; Cloud Hosting Services - Google Cloud Platform</title>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="/images/gcp-favicon.ico">
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">

    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->

    <meta name="google-site-verification" content="8dOEM3Xenm6yaBc83y2WKgqQG0iHI7Ph6Rl_YLIZLQ8" />
    <meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
    
    <!-- GSAP animation frameworks -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
    <script src="//www.gstatic.com/external_hosted/gsap/TweenMax.min.js"></script>
    <script src="//www.gstatic.com/external_hosted/gsap/TimelineMax.min.js"></script>
    <script src="/js/floodlight.js"></script>
    
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
    <link href="//www.google.com/css/maia.experimental.css" rel="stylesheet">
    <link href="/css/maia-cloud.css" rel="stylesheet"/>
    <link href="/css/default.css" rel="stylesheet">
  </head>
  <body>
  <div id="maia-header">
    <div class="maia-aux">
      <h1><a href="/"><img src="/images/gcp-logo.png" alt="Cloud Platform" data-retina="383x48"></a></h1>

<div class="search-container">
  <form action="/search" class="maia-search">
    <input type="text" placeholder="Search this site" name="q">
    <button class="maia-button" type="submit" data-g-event="Maia: Button" data-g-action="Maia: Primary – Header" data-g-label="Search">
      <span class="maia-search-icon">Buscar</span>
    </button>
  </form>
  <div class="cloud-social">
    
    <div class="cloud-signed-in">
      <a href="/console" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Go to my console">Go to my console</a> | <a href="https://www.google.com/accounts/Logout?continue=https://cloud.google.com/&amp;service=ahsid" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Sign out">Sign out</a>
    </div>
    
  </div>
  
</div>
  
</div>

    </div>
  </div>
  <div id="maia-nav-x" class="maia-nav">
    <div class="maia-aux">
   <div class="cp-cta">
     <a class="cp-track maia-button maia-button-secondary white-button" href="/es/contact/">Contactar con ventas</a>
     
       <a class="cp-track maia-button blue-button" href="https://console.developers.google.com?getstarted=https://cloud.google.com" style="color: #ffffff;">Probar ahora</a>
     
   </div>
      <ul>
        <li >
            <a href="/es/why-google/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Why Google">
            Por qué Google
            </a>
        </li>
        <li  id="main-nav-product-dropdown" class="dropdown">
            <a href="/es/products/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Products">
            Productos
            </a>
        </li>
        <li >
            <a href="/es/solutions/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Solutions">
            Soluciones
            </a>
        </li>
        <li >
            <a href="/es/customers/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Customers">
            Clientes
            </a>
        </li>
        <li  class="active" >
            <a href="/es/developers/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Developers">
          Desarrolladores
            </a>
        </li>
        <li >
            <a href="/es/support/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Support">
            Soporte
            </a>
        </li>
        <li >
            <a href="/es/partners/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Partners">
            Partners
            </a>
        </li>
        <li>
            <a href="https://github.com/GoogleDevDocs/googledevdocs.github.io/edit/master/es/developers/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore.html" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Edit Page">
            Edit Page
            </a>
        </li>
      </ul>
    </div>
  </div>

<!-- Products subnav -->
<div id="maia-nav-x" class="maia-nav products-nav">
  <div class="maia-aux">
    <div class="products-nav-dropdown maia-cols">

      <div id="compute-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Compute</span>
        <div class="dropdown-item-container">
          <a href="/products/compute-engine/">
            <span class="product-name">Compute Engine</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/app-engine/">
            <span class="product-name">App Engine</span>
          </a>
        </div>
      </div>

      <div id="storage-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Storage</span>
        <div class="dropdown-item-container">
          <a href="/products/cloud-sql/">
            <span class="product-name">Cloud SQL</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-storage/">
            <span class="product-name">Cloud Storage</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-datastore/">
            <span class="product-name">Cloud Datastore</span>
          </a>
        </div>
      </div>

      <div id="big-data-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Big Data</span>
        <div class="dropdown-item-container">
          <a href="/products/bigquery/">
            <span class="product-name">BigQuery</span>
          </a>
        </div>
      </div>

      <div id="services-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Services</span>
        <div class="dropdown-item-container">
          <a href="/products/cloud-dns/">
            <span class="product-name">Cloud DNS</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-endpoints/">
            <span class="product-name">Cloud Endpoints</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/translate-api/">
            <span class="product-name">Translate API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/prediction-api/">
            <span class="product-name">Prediction API</span>
          </a>
        </div>
      </div>

      <div id="management-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Management</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/cloud-deployment-manager/">Cloud Deployment Manager</a></span>
        </div>
      </div>

      <div id="pricing-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Pricing</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/pricing/">Overview</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/calculator/">Calculator</a></span>
        </div>
      </div>
    </div>
  </div>
</div>

<!DOCTYPE html>
<html devsite="">
<head>
<title>Web Apps Articles &amp; Tutorials — Google Cloud Platform</title>
<meta name="description" content="Read technical articles about web applications and solutions with Google Cloud Platform, including auto scaling and how to manage complex applications in the cloud.">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/css/cp-ie.css'>
    <![endif]-->
<script src="/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Equilibrio de coherencia fija y eventual con Google Cloud Datastore</h1>
</div>
<div class="cp-article-tutorial">
<h2><a name="h.4n3hcboreol0" id="h.4n3hcboreol0"></a>Experiencia de usuario coherente y aprovechamiento del modelo de coherencia eventual para escalar a grandes conjuntos de datos</h2>
<p>En este documento se analiza cómo lograr una coherencia fija para que la experiencia de usuario sea positiva, a la vez que se adopta el modelo de coherencia eventual de Google Cloud Datastore para gestionar grandes cantidades de datos y de usuarios.</p>
<p>Este documento está dirigido a los arquitectos y a los ingenieros de software que quieran crear soluciones en Google Cloud Datastore. Para ayudar a los lectores que conocen mejor las bases de datos relacionales que los sistemas no relacionales como Google Cloud Datastore, en este documento se señalan conceptos análogos de las bases de datos relacionales. Se da por supuesto que tienes un conocimiento básico de Google Cloud Datastore. La forma más fácil de empezar a utilizar Google Cloud Datastore es que en Google App Engine se utilice uno de los lenguajes compatibles: Python, Java, Go o PHP. Si nunca has utilizado App Engine, te recomendamos que primero leas la <a href="https://developers.google.com/appengine/">Guía de introducción</a> y la sección <a href="https://developers.google.com/appengine/docs/python/storage">Almacenamiento de datos</a> correspondiente a uno de esos lenguajes. Aunque se utiliza Python en los fragmentos de código de ejemplo, no es necesario tener experiencia en este lenguaje para poder seguir leyendo este documento.</p>
<h4>Contenido</h4>
<p><a class="indnt" href="#h.w3kz4fze562t">NoSQL y coherencia eventual</a><br>
<a class="indnt" href="#h.tf76fya5nqk8">Coherencia eventual en Google Cloud Datastore</a><br>
<a class="indnt" href="#h.3loc7ynqbw6i">Consulta de antecedente y grupo de entidades</a><br>
<a class="indnt" href="#h.ooaauy74mue8">Limitaciones del grupo de entidades y de la consulta de antecedente</a><br>
<a class="indnt" href="#h.k31yisins6ul">Alternativas a las consultas de antecedente</a><br>
<a class="indnt" href="#h.buvz7spe7ytk">Minimización del tiempo para lograr la coherencia total</a><br>
<a class="indnt" href="#h.njxgygqflg9k">Conclusión</a><br>
<a class="indnt" href="#h.ywh7cedcuhkk">Recursos adicionales</a></p>
<h2><a name="h.w3kz4fze562t" id="h.w3kz4fze562t"></a>NoSQL y coherencia eventual</h2>
<p>Las bases de datos no relacionales, también conocidas como bases de datos NoSQL, han surgido en los últimos años como una alternativa a las bases de datos relacionales. Google Cloud Datastore es una de las bases de datos no relacionales con mayor aceptación en el sector. En 2013, Google Cloud Datastore procesó 4,5 billones de transacciones al mes (<a href="http://googlecloudplatform.blogspot.com/2013/05/reducing-app-engine-datastore-pricing-by-up-to-25-percent.html">entrada de blog sobre Google Cloud Platform</a>). Proporciona un método simplificado para que los desarrolladores almacenen sus datos y accedan a ellos. El esquema flexible se asigna de manera natural a los lenguajes orientados a objetos y de secuencia de comandos. Google Cloud Datastore también proporciona una serie de características para las que las bases de datos relacionales no están bien equipadas, incluido el alto rendimiento a gran escala y la alta fiabilidad.</p>
<p>En el caso de los desarrolladores más acostumbrados a las bases de datos relacionales, puede suponer un reto diseñar un sistema que aproveche las bases de datos no relacionales, ya que algunas características y algunas prácticas de las bases de datos no relacionales les pueden resultar relativamente desconocidas. Aunque el modelo de programación de Google Cloud Datastore es sencillo, es importante estar al tanto de estas características. La coherencia eventual es una de estas características y la programación para la coherencia eventual es el tema principal de este documento.</p>
<h3><a name="h.86naen3bqe0" id="h.86naen3bqe0"></a>¿Qué es la coherencia eventual?</h3>
<p>La <span class="bld">coherencia eventual</span> es una garantía teórica de que, siempre que no se modifique una entidad, todas las consultas de la entidad al final ofrecerán como resultado el último valor actualizado. El sistema de nombres de dominio (DNS) de Internet es un ejemplo muy conocido de un sistema con un modelo de coherencia eventual. Los servidores DNS no reflejan los valores más recientes por fuerza, sino que más bien los valores se almacenan en la memoria caché y se replican en muchos directorios por Internet. La replicación de los valores modificados a todos los clientes y servidores de DNS supone cierta dedicación de tiempo. Sin embargo, el sistema DNS es un sistema de gran popularidad que se ha convertido en uno de los pilares de Internet. Como su disponibilidad es muy alta y ha demostrado ser sumamente escalable, permite búsquedas de nombres a más de cien millones de dispositivos en toda la Internet.</p>
<p>En la figura 1 se ilustra el concepto de la replicación con la coherencia eventual. El diagrama muestra que, aunque siempre hay réplicas disponibles para consultarlas, puede que en un momento concreto algunas no sean coherentes con la última modificación hecha en el nodo de origen. En el diagrama, el nodo A es el nodo de origen y los nodos B y C son las réplicas.</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/eventual-consistency.png" alt="">
<figcaption>Figura 1. Representación conceptual de la replicación con coherencia eventual</figcaption>
</figure>
<p>En contraste, las bases de datos relacionales tradicionales se han diseñado basándose en el concepto de coherencia fija, también llamado coherencia inmediata. Esto quiere decir que los datos consultados justo después de una actualización serán coherentes para todos los observadores de la entidad. Esta característica ha sido una premisa fundamental para muchos desarrolladores que utilizan bases de datos relacionales. Sin embargo, para tener una coherencia fija, los desarrolladores deben sacrificar la escalabilidad y el rendimiento de su aplicación. Dicho en pocas palabras, los datos se tienen que bloquear durante el periodo de actualización o durante el proceso de replicación para asegurarse de que ningún otro proceso esté actualizando los mismos datos.</p>
<p>En la figura 2 se muestra una vista conceptual de la topología de implementación y del proceso de replicación con coherencia fija. En este diagrama, puedes ver que las réplicas siempre tienen valores coherentes con el nodo de origen, pero que no son accesibles hasta que finaliza la actualización.</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/strong-consistency.png" alt="">
<figcaption>Figura 2. Representación conceptual de la replicación con coherencia fija</figcaption>
</figure>
<h3><a name="h.rcbsdmar23fq" id="h.rcbsdmar23fq"></a>Equilibrio de coherencia fija y eventual</h3>
<p>Las bases de datos no relacionales se han popularizado en los últimos tiempos, sobre todo para las aplicaciones web que necesitan alta escalabilidad y rendimiento con una alta disponibilidad. Las bases de datos no relacionales permiten a los desarrolladores elegir un equilibrio óptimo entre coherencia fija y eventual para cada aplicación. Esto les permite combinar las ventajas de ambos mundos. Por ejemplo, información como saber quién de tu lista de amigos está online en un momento dado o saber cuántos usuarios han hecho +1 en tu entrada son casos de uso en los que no se necesita la coherencia fija. Una forma de proporcionar escalabilidad y rendimiento para estos casos de uso es aprovechar la coherencia eventual. Los casos de uso que requieren coherencia fija incluyen información como si un usuario ha finalizado el proceso de facturación o no o el número de puntos que ha ganado un jugador durante una sesión de batalla.</p>
<p>Para generalizar los ejemplos que acabamos de dar, podemos decir que los casos de uso con un gran número de entidades suelen sugerir que la coherencia eventual es el modelo idóneo. Si hay un gran número de resultados en una consulta, la experiencia de usuario puede que no se vea afectada por la inclusión o por la exclusión de entidades específicas. Por otro lado, los casos de uso con un pequeño número de entidades y con un contexto limitado sugieren que es necesario optar por la coherencia fija. La experiencia de usuario se verá afectada porque el contexto hará que los usuarios sean conscientes de las entidades que se deben incluir o excluir.</p>
<p>Por estos motivos, es importante que los desarrolladores entiendan las características no relacionales de Google Cloud Datastore. En las secciones siguientes se describe cómo combinar los modelos de coherencia fija y eventual para crear una aplicación escalable, de alta disponibilidad y de gran rendimiento. Si se hace así, también se cumplirán los requisitos de coherencia para lograr una experiencia de usuario positiva.</p>
<h2><a name="h.tf76fya5nqk8" id="h.tf76fya5nqk8"></a>Coherencia eventual en Google Cloud Datastore</h2>
<p>Cuando se requiere una vista de coherencia fija de los datos, se debe seleccionar la API correcta. Las diferentes variedades de las API de consulta de Google Cloud Datastore y sus modelos de coherencia correspondientes se muestran en la tabla 1.</p>
<a href="#" name="73aa40d03f7c0cd78a8b69d986cc7d802f3e49eb" id="73aa40d03f7c0cd78a8b69d986cc7d802f3e49eb"></a><a href="#" name="2" id="2"></a>
<figure>
<table class="brdr-table" style="text-align:left;">
<tbody>
<tr>
<th>
<p>API de Google Cloud Datastore</p>
</th>
<th>
<p>Lectura del valor de la entidad</p>
</th>
<th>
<p>Lectura del índice</p>
</th>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries">Consulta global</a></p>
</td>
<td>
<p>Coherencia eventual</p>
</td>
<td>
<p>Coherencia eventual</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Keys_only_queries">Consulta global de solo claves</a></p>
</td>
<td>
<p>N/A</p>
</td>
<td>
<p>Coherencia eventual</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Ancestor_queries">Consulta de antecedente</a></p>
</td>
<td>
<p>Coherencia fija</p>
</td>
<td>
<p>Coherencia fija</p>
</td>
</tr>
<tr>
<td>
<p><a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Retrieving_an_entity">Búsqueda por clave</a> (get ())</p>
</td>
<td>
<p>Coherencia fija</p>
</td>
<td>
<p>N/A</p>
</td>
</tr>
</tbody>
</table>
<figcaption>Tabla 1. Consultas y llamadas a get de Google Cloud Datastore y posibles comportamientos en la coherencia</figcaption>
</figure>
<p>Las consultas de Google Cloud Datastore que no tienen antecedente se conocen como <span class="bld">consultas globales</span> y están diseñadas para trabajar con un modelo de coherencia eventual, que no garantiza la coherencia fija. Una consulta global de <span class="bld">solo claves</span> es una <span class="bld">consulta global</span> que solo ofrece como resultado las claves de las entidades que coinciden con la consulta, y no los valores de atributo de las entidades. Una <span class="bld">consulta de antecedente</span> determina el ámbito de la consulta en función de una entidad antecedente. En las siguientes secciones se analiza en más detalle cada comportamiento de coherencia.</p>
<h3><a name="h.cb1okox563r3" id="h.cb1okox563r3"></a>Coherencia eventual al leer valores de entidad</h3>
<p>A excepción de las consultas de antecedentes, puede que el valor actualizado de una entidad no se pueda ver de inmediato al ejecutar una consulta. Para entender el efecto de la coherencia eventual al leer los valores de entidad, imagina una situación en la que una entidad, Jugador, tiene una propiedad, Puntuación. Imagina, por ejemplo, que la Puntuación inicial tenga un valor de 100. Pasado un tiempo, el valor de Puntuación cambia a 200. Si se ejecuta una consulta global y se incluye la misma entidad Jugador en el resultado, es posible que el valor de la propiedad Puntuación de la entidad ofrecida como resultado aparezca sin cambios, en 100.</p>
<p>Este comportamiento se debe a la replicación entre servidores de Google Cloud Datastore. Los encargados de administrar la replicación son Bigtable y Megastore, las tecnologías subyacentes para Google Cloud Datastore (consulta <a href="#h.ywh7cedcuhkk">Recursos adicionales</a> para obtener más detalles sobre Bigtable y sobre Megastore). La replicación se ejecuta con el algoritmo <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a>, que espera de manera síncrona hasta que una mayoría de las réplicas haya reconocido la solicitud de actualización. La réplica se actualiza con datos de la solicitud transcurrido un periodo de tiempo. Este periodo suele ser breve, pero no se puede garantizar su duración real. Puede que una consulta lea los datos obsoletos si se ejecuta antes de que finalice la actualización.</p>
<p>En muchos casos, la actualización alcanzará todas las réplicas muy rápidamente. Sin embargo, hay varios factores que, combinados, pueden prolongar el tiempo que se tarda en lograr la coherencia. Estos factores incluyen las incidencias en todo el centro de datos que impliquen cambiar una gran cantidad de servidores entre centros de datos. Teniendo en cuenta la variación de estos factores, es imposible proporcionar un requisito de tiempo definitivo para establecer la plena coherencia.</p>
<p>El tiempo necesario para que una consulta ofrezca el último valor suele ser muy breve. Sin embargo, en situaciones excepcionales en las que la latencia de replicación aumenta, puede ser mucho más largo. Las aplicaciones que utilizan consultas globales de Google Cloud Datastore se tienen que diseñar cuidadosamente para que gestionen estos casos con agilidad.</p>
<p>La coherencia eventual al leer valores de entidad se puede evitar si se usa una consulta de solo claves, una consulta de antecedente o una búsqueda por clave (método get()). Más adelante analizaremos más a fondo los diferentes tipos de consulta.</p>
<h3><a name="h.4xdytk3hj44" id="h.4xdytk3hj44"></a>Coherencia eventual al leer un índice</h3>
<p>Puede que un índice aún no esté actualizado cuando se ejecute una consulta global. Esto quiere decir que, aunque es posible que puedas leer los valores de propiedad más recientes de las entidades, la "lista de entidades" incluida en el resultado de la consulta puede estar filtrada en función de valores de índice antiguos.</p>
<p>Para entender el efecto que la coherencia eventual tiene en la lectura de un índice, imagina una situación en la que una nueva entidad, Jugador, se inserte en Google Cloud Datastore. La entidad tiene una propiedad, Puntuación, que tiene un valor inicial de 300. Inmediatamente después de la inserción, ejecutas una consulta de solo claves para obtener todas las entidades con un valor de Puntuación superior a 0. Lo previsible a continuación es que la entidad Jugador, recién insertada, aparezca en los resultados de la consulta. Sin embargo puede que, de manera imprevista, la entidad Jugador no aparezca en los resultados. Esta situación puede ocurrir cuando la tabla de índice de la propiedad Puntuación no se actualiza con el valor que se acaba de insertar en el momento de ejecución de la consulta.</p>
<p>Recuerda que todas las consultas que se envían a Google Cloud Datastore se ejecutan con <a href="https://developers.google.com/appengine/docs/python/datastore/indexes#Python_Index_definition_and_structure">tablas de índices</a> como referencia y, sin embargo, <a href="https://developers.google.com/appengine/articles/life_of_write">los cambios hechos a las tablas de índice son asíncronos</a>. Cada cambio hecho en la entidad se compone, fundamentalmente, de dos fases. En la primera fase, confirmación, se realiza una modificación en el registro de transacciones. En la segunda fase, se crean datos y se actualizan los índices. Si la fase de confirmación es satisfactoria, la fase de modificación tiene garantía de éxito, aunque puede que no se produzca de inmediato. Si envías una consulta a una entidad antes de que se actualicen los índices, puede que acabes viendo datos que aún no son coherentes.</p>
<p>Como resultado de este proceso en dos fases, hay un retraso antes de que los últimos cambios realizados en las entidades estén visibles en las consultas globales. Al igual que con la coherencia eventual de un valor de entidad, el retraso suele ser breve, pero se puede alargar (hasta minutos o más en circunstancias excepcionales).</p>
<p>Lo mismo puede suceder también después de cambios. Por ejemplo, si modificas una entidad existente, Jugador, con un nuevo valor para la propiedad Puntuación de 0 y ejecutas la misma consulta justo después. Lo previsible es que la entidad no aparezca en los resultados de la consulta porque el nuevo valor de Puntuación, 0, la excluiría. Sin embargo, debido al mismo comportamiento en la modificación de índice asíncrona, es posible que la entidad se siga incluyendo en el resultado.</p>
<p>La coherencia eventual en la lectura de un índice solo se puede evitar si se usa un método de consulta de antecedente o de búsqueda por clave. Una consulta de solo claves no puede evitar este comportamiento.</p>
<h3><a name="h.ubkfi6o13a4f" id="h.ubkfi6o13a4f"></a>Coherencia fija en la lectura de índices y de valores de entidad</h3>
<p>En Google Cloud Datastore, solo hay dos API que proporcionan una vista de coherencia fija para la lectura de índices y de valores de entidad: 1) el método de búsqueda por clave y 2) la consulta de antecedente. Si la lógica de la aplicación necesita una coherencia fija, el desarrollador debería usar uno de estos métodos para leer entidades de Google Cloud Datastore.</p>
<p>Google Cloud Datastore está diseñado en concreto para proporcionar coherencia fija en estas API. Al llamar a una de ellas, Google Cloud Datastore vaciará todos los cambios pendientes en una de las réplicas y en una de las tablas de índice, y, a continuación, ejecutará la búsqueda o la consulta de antecedente. Por lo tanto, el valor de entidad más reciente, basado en la tabla de índices modificada, siempre se ofrece con valores basados en las modificaciones más recientes.</p>
<p>La llamada de búsqueda por clave, a diferencia de las consultas, solo ofrece como resultado una entidad o un conjunto de entidades especificadas por una clave o por un conjunto de claves. Esto quiere decir que la única manera de que Google Cloud Datastore cumpla un requisito de coherencia fija junto con un requisito de filtrado es enviar una consulta de antecedente. Sin embargo, las consultas de antecedente no funcionan si no se especifica un <span class="bld">grupo de entidades</span>.</p>
<h2><a name="h.3loc7ynqbw6i" id="h.3loc7ynqbw6i"></a>Consulta de antecedente y grupo de entidades</h2>
<p>Como se ha analizado al principio de este documento, una de las ventajas de Google Cloud Datastore es que los desarrolladores pueden encontrar un equilibrio idóneo entre la coherencia fija y la coherencia eventual. En Google Cloud Datastore, un <a href="https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency">grupo de entidades</a> es una unidad con coherencia fija, con transaccionalidad y con localidad. Si utilizan grupos de entidades, los desarrolladores pueden definir el ámbito de la coherencia fija entre las entidades de una aplicación. De esta manera, la aplicación puede mantener la coherencia dentro del grupo de entidades a la vez que consigue alta escalabilidad, alta disponibilidad y alto rendimiento como un sistema completo.</p>
<p>Un grupo de entidades es una jerarquía formada por una entidad raíz y sus elementos secundarios o sucesores.<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup> Para crear un grupo de entidades, los desarrolladores tienen que especificar una ruta de antecedentes que, básicamente, es una serie de claves principales que prefijan la clave secundaria. El concepto "grupo de entidades" se ilustra en la figura 3. En este caso, la entidad raíz con la clave "ateam" tiene dos elementos secundarios con las claves "ateam/098745" y "ateam/098746".</p>
<figure><img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/croup-concept.png" alt="">
<figcaption>Figura 3. Vista esquemática del concepto "grupo de entidades"</figcaption>
</figure>
<p>Dentro del grupo de entidades, las siguientes características están garantizadas:</p>
<ul>
<li>Coherencia fija
<ul>
<li>Una consulta de antecedente en el grupo de entidades ofrecerá un resultado de coherencia fija. De esta manera, se reflejan los valores de entidad más recientes filtrados por el estado de índice más reciente.</li>
</ul>
</li>
<li>Transaccionalidad
<ul>
<li>Al demarcar una transacción mediante programación, el grupo de entidades proporciona las características ACAD (atomicidad, coherencia, aislamiento y durabilidad) de la transacción.</li>
</ul>
</li>
<li>Localidad
<ul>
<li>Las entidades de un grupo de entidades se almacenarán en lugares físicamente cercanos en servidores de Google Cloud Datastore, ya que todas las entidades se ordenan y se almacenan según el orden lexicográfico de las claves. Esto permite que una consulta de antecedente escanee rápidamente el grupo de entidades con un número mínimo de E/S.</li>
</ul>
</li>
</ul>
<p>Una consulta de antecedente es una forma especial de consulta que solo se ejecuta tomando un grupo de entidades especificado como referencia. Se ejecuta con coherencia fija. En segundo plano, Google Cloud Datastore garantiza que todas las replicaciones y las modificaciones de índice pendientes se hagan efectivas antes de ejecutar la consulta.</p>
<h3><a name="h.pyro8j6ki6tn" id="h.pyro8j6ki6tn"></a>Ejemplo de consulta de antecedente</h3>
<p>En esta sección se describe cómo poner en práctica los grupos de entidades y las consultas de antecedente. En el siguiente ejemplo, tenemos en cuenta el problema que supone administrar los registros de datos de personas. Supongamos que tenemos código que añade una entidad de un tipo específico seguida de inmediato de una consulta de ese tipo. Este concepto se demuestra con el código Python de ejemplo que hay a continuación.</p>
<pre>
# Define the Person entity
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
    organization = db.StringProperty()
# Add a person and retrieve the list of all people
class MainPage(webapp2.RequestHandler):
    def post(self):
        person = Person(given_name='GI', surname='Joe', organization='ATeam')
        person.put()
        q = db.GqlQuery("SELECT * FROM Person")
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname,
                        'organization': p.organization})
</pre>
<p>El problema de este código es que, en la mayoría de los casos, la consulta no ofrecerá la entidad añadida en la declaración anterior. Como la consulta sigue en la línea que va justo después de la inserción, el índice no se actualizará cuando se ejecute la consulta. Sin embargo, también hay un problema con la validez de este caso de uso, que es si de verdad hay necesidad de ofrecer una lista de todas las persona de una página sin contexto. ¿Qué ocurre si hay un millón de personas? La página tardaría demasiado en ofrecer resultados.</p>
<p>La naturaleza del caso de uso sugiere que debemos proporcionar algún tipo de contexto para reducir la consulta. En este ejemplo, el contexto que vamos a utilizar será la organización. En ese caso, podemos utilizar la organización como un grupo de entidades y ejecutar una consulta de antecedente, que resuelve el problema de coherencia. Esta situación se demuestra con el código Python que hay a continuación.</p>
<pre>
class Organization(db.Model):
    name = db.StringProperty()
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
class MainPage(webapp2.RequestHandler):
    def post(self):
        org = Organization.get_or_insert('ateam', name='ATeam')
        person = Person(parent=org)
        person.given_name='GI'
        person.surname='Joe'
        person.put()
        q = db.GqlQuery("SELECT * FROM Person WHERE ANCESTOR IS :1 ", org)
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname})
</pre>
<p>Esta vez, con el antecedente org especificado en GqlQuery, la consulta ofrece como resultado la entidad que se acaba de insertar. El ejemplo se podría ampliar para profundizar en una persona concreta mediante la consulta del nombre de la persona con el antecedente como parte de la consulta. De manera alternativa, esto también se podría haber hecho reservando la clave de entidad y después utilizándola para profundizar con una búsqueda por clave.</p>
<h3><a name="h.l10xxpfjg70q" id="h.l10xxpfjg70q"></a>Mantenimiento de la coherencia entre Memcache y Google Cloud Datastore</h3>
<p>Los grupos de entidades también se pueden utilizar como una unidad para mantener la coherencia entre las entradas de Memcache y las entidades de Google Cloud Datastore. Por ejemplo, en una situación en la que se cuente el número de personas en cada equipo y se almacene en Memcache. Para asegurarte de que los datos almacenados en la memoria caché sean coherentes con los valores más recientes de Google Cloud Datastore, puedes usar <a href="https://developers.google.com/appengine/docs/python/datastore/metadataqueries#Python_Entity_group_metadata">metadatos del grupo de entidades</a>. Los metadatos ofrecen el número de la versión más reciente del grupo de entidades especificado. Puedes comparar el número de versión con el número almacenado en Memcache. Con este método, puedes detectar un cambio en cualquiera de las entidades de todo el grupo de entidades con tan solo leer un conjunto de metadatos, en vez de escanear las entidades del grupo una a una.</p>
<h2><a name="h.ooaauy74mue8" id="h.ooaauy74mue8"></a>Limitaciones del grupo de entidades y de la consulta de antecedente</h2>
<p>El método que consiste en utilizar grupos de entidades y consultas de antecedente no es la panacea. En la práctica hay dos dificultades que hacen que sea difícil aplicar la técnica en general, como se indica a continuación.</p>
<ol class="c28 lst-kix_qyusimaqza9q-0 start" start="1">
<li>Las actualizaciones están limitadas a una por segundo para cada grupo de entidades.</li>
<li>La relación del grupo de entidades no se puede cambiar después de crear una entidad.</li>
</ol>
<h3><a name="h.8yrg89iapdjp" id="h.8yrg89iapdjp"></a>Límite de modificación</h3>
<p>Un problema importante es que el sistema tiene que estar diseñado para contener el número de modificaciones (o transacciones) de cada grupo de entidades. El límite admitido es una modificación por segundo por cada grupo de entidades.<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup> Si el número de modificaciones tiene que ser superior al límite, el grupo de entidades se podría convertir en un cuello de botella para el rendimiento.</p>
<p>En el ejemplo anterior, cada organización podría tener que modificar el registro de cualquier persona de la organización. Imagina una situación en la que haya 1.000 personas en el "ateam" y que cada persona tuviera una modificación por segundo en cualquiera de las propiedades. Como resultado, podría haber hasta 1.000 modificaciones por segundo en el grupo de entidades, un resultado que no se podría lograr debido al límite de modificaciones. Esto pone de manifiesto la importancia de elegir un diseño adecuado para los grupos de entidades que tenga en cuenta los requisitos de rendimiento. Esta es una de las dificultades a la hora de encontrar el equilibrio idóneo entre la coherencia eventual y la coherencia fija.</p>
<h3><a name="h.slap2zz3i3rk" id="h.slap2zz3i3rk"></a>Inmutabilidad de las relaciones del grupo de entidades</h3>
<p>Una segunda dificultad es la inmutabilidad de las relaciones del grupo de entidades. La relación del grupo de entidades se forma de manera estática en función de los nombres clave. No se puede cambiar después de crear la entidad. La única opción disponible para cambiar la relación es eliminar las entidades de un grupo de entidades y volver a crearlas. Esta dificultad nos impide usar los grupos de entidades para definir de manera dinámica ámbitos a medida para la coherencia o para la transaccionalidad. En cambio, el ámbito de la coherencia o de la transaccionalidad está estrechamente vinculado al grupo de entidades estático que se define en el momento de diseñar.</p>
<p>Pongamos como ejemplo una situación en la que quieras realizar una transferencia bancaria entre dos cuentas. Esta situación empresarial exige coherencia fija y transaccionalidad. Sin embargo, las dos cuentas no se pueden agrupar en un grupo de entidades en el último momento ni basarse en un elemento superior global. Ese grupo de entidades crearía un cuello de botella en todo el sistema que entorpecería la ejecución de otras solicitudes de transferencias bancarias. Por lo tanto, los grupos de entidades no se pueden utilizar en este modo.</p>
<p>Sin embargo, existe una alternativa para realizar una transferencia bancaria de manera altamente escalable y asegurando la disponibilidad. Un método para cumplir este requisito es usar <a href="https://developers.google.com/appengine/docs/python/datastore/#Python_Cross_group_transactions">transacciones entre grupos (XG)</a> para la transaccionalidad, y el método de búsqueda por clave de Google Cloud Datastore o una consulta de antecedente para la coherencia. Las transacciones entre grupos son una característica de Google Cloud Datastore que te permite tener las características ACAD para un máximo de cinco grupos de entidades o entidades en una sola transacción. Si utilizas transacciones entre grupos, puedes formar de manera dinámica un ámbito de transacción con las dos cuentas bancarias en el momento de procesar la solicitud.</p>
<p>Ten en cuenta que las transacciones entre grupos solo garantizan la transaccionalidad. Para garantizar la coherencia fija al leer las dos cuentas bancarias, debes utilizar el método de búsqueda por clave o una consulta de antecedente. Si intentas ejecutar una consulta que no sea de antecedente dentro de una transacción, recibirás un error.</p>
<h2><a name="h.k31yisins6ul" id="h.k31yisins6ul"></a>Alternativas a las consultas de antecedente</h2>
<p>Si ya tienes una aplicación con un gran número de entidades almacenadas en Google Cloud Datastore, puede que resulte difícil incorporar después grupos de entidades en un ejercicio de refactorización. Haría falta eliminar todas las entidades y añadirlas dentro de una relación del grupo de entidades. Por lo tanto, al realizar modelos de datos para Google Cloud Datastore, es importante tomar una decisión sobre el diseño de grupo de entidades en una fase temprana del diseño de la aplicación. De lo contrario, puede que en la refactorización te veas limitado a otras alternativas para lograr un cierto nivel de coherencia, como puede ser una consulta de solo claves seguida de una búsqueda por clave o seguida del uso de Memcache.</p>
<h3><a name="h.56geqhlrqja4" id="h.56geqhlrqja4"></a>Consulta global de solo claves seguida de una búsqueda por clave</h3>
<p>Una consulta global de solo claves es un tipo especial de consulta global que solo ofrece como resultado las claves sin los valores de propiedad de las entidades. Como los valores ofrecidos son solo claves, la consulta no implica un valor de entidad con un posible problema de coherencia. Una combinación de la consulta global de solo claves con un método de búsqueda leerá los valores de entidad más recientes. De cualquier modo, se debe señalar que una consulta global de solo claves no puede excluir la posibilidad de que un índice aún no sea coherente en el momento de la consulta, que podría provocar que una entidad no se obtuviera en absoluto. Habría probabilidades de que el resultado de la consulta se generara basándose en un filtrado para excluir los valores de índice antiguos. En resumen, un desarrollador solo puede utilizar consultas globales de solo claves seguidas de una búsqueda por clave cuando un requisito de la aplicación permita que el valor de índice aún no sea coherente en el momento de realizar una consulta.</p>
<h3><a name="h.kzvtug7i4vlw" id="h.kzvtug7i4vlw"></a>Uso de Memcache</h3>
<p>El servicio de Memcache es volátil, pero muy coherente. Esto quiere decir que, si se combinan búsquedas de Memcache con consultas de Google Cloud Datastore, es posible crear un sistema que minimice los problemas de coherencia la mayor parte del tiempo.</p>
<p>Utilizaremos como ejemplo una aplicación de juego que mantiene una lista de entidades Jugador, cada una con una puntuación superior a cero.</p>
<ul>
<li>En el caso de las solicitudes de inserción o de actualización, aplícalas a la lista de entidades Jugador en Memcache y en Google Cloud Datastore</li>
<li>En el caso de las solicitudes de consulta, lee la lista de entidades Jugador de Memcache y ejecuta una consulta de solo claves en Google Cloud Datastore cuando la lista no esté presente en Memcache</li>
</ul>
<p>La lista ofrecida será coherente siempre que la lista almacenada en la memoria caché esté presente en Memcache. Si la entrada se ha expulsado o si el servicio de Memcache no está disponible temporalmente, es posible que el sistema tenga que leer el valor de una consulta de Google Cloud Datastore, que podría ofrecer un resultado incoherente. Esta técnica se puede aplicar a cualquier aplicación que tolere una pequeña cantidad de incoherencia.</p>
<p>Hay algunas prácticas recomendadas a la hora de utilizar Memcache como una capa de almacenamiento en la memoria caché para Google Cloud Datastore:</p>
<ul>
<li>Detecta las excepciones y los errores de Memcache para mantener la coherencia entre el valor de Memcache y el valor de Google Cloud Datastore. Si recibes una excepción al actualizar la entrada en Memcache, asegúrate de invalidar la entrada anterior en Memcache. De lo contrario, podría haber diferentes valores para una entidad (un valor anterior en Memcache y un valor nuevo en Google Cloud Datastore).</li>
<li>Establece un <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_How_cached_data_expires">periodo de caducidad</a> en las entradas de Memcache. Se recomienda establecer periodos cortos para la caducidad de cada entrada para minimizar la posibilidad de que haya incoherencias en el caso de las excepciones de Memcache.</li>
<li>Utiliza la característica de <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_Using_compare_and_set_in_Python">comparación y definición</a> cuando modifiques las entradas del control de simultaneidad. Así ayudarás a garantizar que las modificaciones simultáneas hechas en la misma entrada no interfieran entre sí.</li>
</ul>
<h3><a name="h.ooddikjhrygc" id="h.ooddikjhrygc"></a>Migración gradual a grupos de entidades</h3>
<p>Las sugerencias hechas en la sección anterior solo disminuyen la posibilidad de que se produzca un comportamiento incoherente. La mejor opción cuando se necesite coherencia fija es diseñar la aplicación basándose en grupos de entidades y en consultas de antecedente. Sin embargo, puede que no sea factible migrar una aplicación existente, que podría incluir el cambio de un modelo de datos existente y la lógica de la aplicación para pasar de consultas globales a consultas de antecedente. Una forma de lograr este objetivo es llevar a cabo un proceso de transición gradual, como podría ser el siguiente:</p>
<ol class="c28 lst-kix_gkyism9dw6ma-0 start" start="1">
<li>Identificar y priorizar las funciones de la aplicación que necesitan coherencia fija.</li>
<li>Escribir lógica nueva para las funciones insert() o update() mediante grupos de entidades además de la lógica existente (en vez de sustituirla). De esta manera, todas las inserciones o las modificaciones nuevas que se hagan tanto en los nuevos grupos de entidades como en las entidades antiguas se pueden gestionar con una función adecuada.</li>
<li>Modificar la lógica existente para las funciones de lectura o de consulta. Las consultas de antecedente se realizan en primer lugar si existe un nuevo grupo de entidades para la solicitud. Ejecuta la consulta global antigua como lógica de respaldo si el grupo de entidades no existe.</li>
</ol>
<p>Esta estrategia permite una migración gradual desde un modelo de datos existente a un nuevo modelo de datos basado en grupos de entidades. Esta migración minimiza el riesgo de problemas causados por la coherencia eventual. En la práctica, este método depende de casos de uso y de requisitos específicos para su aplicación a un sistema real.</p>
<h3><a name="h.gj5afnup3sr9" id="h.gj5afnup3sr9"></a>Vuelta al modo degradado como respaldo</h3>
<p>En la actualidad, es difícil detectar una situación con programación si una aplicación tiene la coherencia deteriorada. Sin embargo, en algunos casos como, por ejemplo, si se supervisan casos de ayuda al cliente, puede que sea posible. Si ese es el caso, quizá se pueda implementar un modo degradado que se pueda activar o desactivar para inhabilitar algunas áreas de la lógica de la aplicación que necesiten coherencia fija. Por ejemplo, en vez de mostrar un resultado de consulta incoherente en una pantalla de informes de facturación, se podría mostrar un mensaje de mantenimiento para esa pantalla en concreto. De esta manera, el resto de servicios de la aplicación puede seguir funcionando y, a su vez, se reducen los efectos negativos en la experiencia de usuario.</p>
<h2><a name="h.buvz7spe7ytk" id="h.buvz7spe7ytk"></a>Reducción al mínimo del tiempo para lograr la coherencia total</h2>
<p>En una aplicación grande con millones de usuarios o de terabytes de entidades de Google Cloud Datastore, es posible que el uso inadecuado de Google Cloud Datastore provoque el deterioro de la coherencia. Estas son algunas de esas prácticas:</p>
<ul>
<li>numeración secuencial en claves de entidad,</li>
<li>demasiados índices.</li>
</ul>
<p>Estas prácticas no afectan a las pequeñas aplicaciones. Sin embargo, cuando la aplicación crece hasta hacerse muy grande, estas prácticas aumentan la posibilidad de que hagan falta tiempos más largos para lograr la coherencia. Por eso es mejor evitarlas en las primeras fases del diseño de la aplicación.</p>
<h3><a name="h.rwk0fv57jze5" id="h.rwk0fv57jze5"></a>Patrón no recomendado número 1: numeración secuencial de claves de entidad</h3>
<p>Antes de que se publicara el SDK 1.8.1 de App Engine, Google Cloud Datastore utilizaba una secuencia de pequeños ID enteros con patrones por lo general consecutivos como nombres de claves predeterminados y generados automáticamente. En algunos documentos esto se llama "política heredada" para crear entidades que no tienen nombre de clave especificado para la aplicación. Esta política heredada generaba nombres de clave de entidad con numeración secuencial, como, por ejemplo, 1.000, 1.001, 1.002. Sin embargo, como hemos analizado antes, Google Cloud Datastore almacena entidades según el orden lexicográfico de los nombres de clave; así que es muy probable que esas entidades se almacenen en los mismos servidores de Google Cloud Datastore. Si una aplicación atrae mucho tráfico, esta numeración secuencial podría provocar una concentración de operaciones en un servidor específico, que, a su vez, puede provocar una latencia más larga para la coherencia.</p>
<p>En el SDK 1.8.1 App Engine, Google Cloud Datastore introdujo un nuevo método de numeración de ID con una política predeterminada que utiliza ID dispersos (consulta la documentación de <a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Assigning_identifiers">referencia</a>). Esta política predeterminada genera una secuencia aleatoria de ID de hasta 16 dígitos que se distribuyen de manera más o menos uniforme. Si se utiliza esta política, es probable que el tráfico de la aplicación grande se distribuya mejor entre un conjunto de servidores de Google Cloud Datastore con un tiempo más breve para la coherencia. Se recomienda utilizar la política predeterminada a menos que tu aplicación requiera específicamente compatibilidad con la política heredada.</p>
<p>Si estableces explícitamente nombres de clave en entidades, el esquema de nombres se debe diseñar para acceder a las entidades de manera uniforme en todo el espacio de nombres de clave. Dicho de otro modo, no concentres el acceso en un intervalo determinado, ya que se ordenan según el orden lexicográfico de los nombres de clave. De lo contrario, podría surgir el mismo problema que con la numeración secuencial.</p>
<p>Para entender la distribución no uniforme del acceso en el espacio de claves, imagina un ejemplo en el que las entidades se creen con los nombres de clave secuenciales que se muestran en el siguiente código:</p>
<pre>
p1 = Person(key_name='0001')
p2 = Person(key_name='0002')
p3 = Person(key_name='0003')
...
</pre>
<p>El patrón de acceso de la aplicación puede crear una "zona activa" en un intervalo determinado de los nombres de clave, como tener el acceso concentrado en las entidades Person de reciente creación. En este caso, todas las claves a las que se acceda a menudo tendrán ID más altos. Entonces la carga se puede concentrar en un servidor específico de Google Cloud Datastore.</p>
<p>De manera alternativa, para entender la distribución uniforme en el espacio de claves, imagina que se utilizan largas cadenas aleatorias para los nombres de clave. Esto se ilustra en el siguiente ejemplo:</p>
<pre>
p1 = Person(key_name='t9P776g5kAecChuKW4JKCnh44uRvBDhU')
p2 = Person(key_name='hCdVjL2jCzLqRnPdNNcPCAN8Rinug9kq')
p3 = Person(key_name='PaV9fsXCdra7zCMkt7UX3THvFmu6xsUd')
...
</pre>
<p>Ahora las entidades Person recién creadas se dispersarán en el espacio de claves y en varios servidores. En este caso se da por supuesto que hay un número de entidades Person lo bastante alto.</p>
<h3><a name="h.ou9y4doeg7dm" id="h.ou9y4doeg7dm"></a>Patrón no recomendado número 2: demasiados índices</h3>
<p>En Google Cloud Datastore, si se modifica una entidad, se provocará que se modifiquen todos los índices definidos para ese tipo de entidad (para obtener más detalles, consulta <a href="https://developers.google.com/appengine/articles/life_of_write">Vida de una operación de escritura en el almacén de datos</a>). Si una aplicación utiliza muchos índices personalizados, una modificación podría implicar decenas, centenares o incluso miles de modificaciones en las tablas de índices. En una aplicación grande, un uso excesivo de índices personalizados podría resultar en un aumento de la carga en el servidor y podría aumentar la latencia para lograr la coherencia.</p>
<p>En la mayoría de los casos, se añaden índices personalizados para cumplir requisitos tales como las tareas de asistencia al cliente, de solución de problemas o de análisis de datos. Google <a href="/es/products/big-query">BigQuery</a> es un motor de consulta altamente escalable que puede ejecutar consultas a medida en grandes conjuntos de datos sin índices creados previamente. Es más adecuado para los casos de uso como, por ejemplo, las tareas de asistencia al cliente, de solución de problemas o de análisis de datos que requieren consultas más complejas que las de Google Cloud Datastore.</p>
<p>Una práctica es combinar Google Cloud Datastore y BigQuery para cumplir diferentes requisitos empresariales. Utiliza Google Cloud Datastore para el procesamiento transaccional online (OLTP) que es necesario para la lógica fundamental de la aplicación y usa Google BigQuery para el procesamiento analítico online (OLAP) para las operaciones de backend. Puede que sea necesario implementar un flujo continuo de exportación de datos de Google Cloud Datastore a BigQuery para trasladar los datos necesarios para las consultas.</p>
<p>Además de una implementación alternativa para los índices personalizados, otra recomendación es especificar explícitamente propiedades no indexadas (consulta <a href="https://developers.google.com/appengine/docs/python/ndb/properties#options">Opciones de propiedades</a> en la documentación de referencia). De manera predeterminada, Google Cloud Datastore creará una tabla de índices diferente para cada propiedad indexable de un tipo de entidad. Si tienes 100 propiedades de una clase, habrá 100 tablas de índices de ese tipo y 100 modificaciones adicionales por cada modificación que se haga en una entidad. Por lo tanto, una práctica recomendada es establecer propiedades no indexadas siempre que sea posible y si no son necesarias para una condición de consulta.</p>
<p>Además de reducir la posibilidad de que aumenten los tiempos para lograr la coherencia, estas optimizaciones del índice pueden dar lugar a una reducción bastante importante de los costes de Google Cloud Datastore en una gran aplicación que utilice mucho los índices.</p>
<h2><a name="h.njxgygqflg9k" id="h.njxgygqflg9k"></a>Conclusión</h2>
<p>La coherencia eventual es un elemento esencial de las bases de datos no relacionales que permite a los desarrolladores encontrar un equilibrio óptimo entre la escalabilidad, el rendimiento y la coherencia. Es importante entender cómo se gestiona el equilibrio entre la coherencia eventual y la coherencia fija para diseñar un modelo de datos que sea idóneo para tu aplicación. En Google Cloud Datastore, el uso de grupos de entidades y de consultas de antecedente es la mejor manera de garantizar la coherencia fija en un ámbito de entidades. Si la aplicación no puede incluir grupos de entidades debido a las limitaciones descritas antes, puedes plantearte otras opciones como el uso de consultas de solo claves o de Memcache. En el caso de las aplicaciones de gran tamaño, sigue prácticas recomendadas como, por ejemplo, el uso de ID dispersos y la indexación reducida para disminuir el tiempo necesario para lograr la coherencia. También puede ser importante combinar Google Cloud Datastore con BigQuery para cumplir los requisitos empresariales para consultas complejas y para reducir el uso de índices de Google Cloud Datastore en la medida de lo posible.</p>
<h2><a name="h.ywh7cedcuhkk" id="h.ywh7cedcuhkk"></a>Recursos adicionales</h2>
<p>Los siguientes recursos proporcionan más información sobre los temas tratados en este documento:</p>
<ul>
<li><a href="https://developers.google.com/appengine/docs/python/datastore/">Google App Engine: almacenamiento de datos</a></li>
<li><a href="https://developers.google.com/appengine/articles/datastore/overview">Dominio del almacén de datos (serie)</a></li>
<li><a href="http://googlecloudplatform.blogspot.com/">Blog sobre Google Cloud Platform</a></li>
<li><a href="https://developers.google.com/cloud-sql/">Google Cloud SQL</a></li>
<li><a href="https://developers.google.com/appengine/training/cloud-sql/">Uso de App Engine en Python con Google Cloud SQL</a></li>
<li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/bigtable-osdi06.pdf">Bigtable: un sistema de almacenamiento distribuido para datos estructurados</a></li>
<li><a href="http://googleappengine.blogspot.com/2011/07/app-engine-152-sdk-released.html">SDK 1.5.2 de App Engine publicado</a></li>
<li><a href="http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper32.pdf">Megastore: suministro de almacenamiento escalable de alta disponibilidad para servicios interactivos</a></li>
</ul>
<br>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> Un grupo de entidades también se puede formar si se especifica una sola clave de la entidad raíz o superior, sin almacenar las entidades reales de la entidad raíz o superior, ya que todas las funciones del grupo de entidades se implementan en función de las relaciones entre claves.</p>
<p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> El límite admitido es una modificación por segundo y por grupo de entidades fuera de las transacciones, o bien una transacción por segundo y por grupo de entidades. Si unes varias modificaciones en una transacción, estás limitado a un tamaño máximo de transacción de 10 MB y a la velocidad máxima de escritura del servidor del almacén de datos.</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">Comentarios sobre este documento</a><br>
<br></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'es',
        'region': 'emea',
        'language': 'es'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>

  <!-- Scripts to include both on Goro + Devsite -->
  <script type="text/javascript">
   window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
  </script>

  <!-- GTM implementation -->

  <!-- Start dataLayer -->
    <script>
      dataLayer = [{
        'country': '',
        'region': '',
        'language': 'es'
      }];
    </script>
  <!-- End dataLayer -->

  <!-- Start Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');</script>
  <!-- End Google Tag Manager -->

  <!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro -->
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular-sanitize.js"></script>

  <script src="/js/base.min.js"></script>

<!-- Secondary right-side scroll-nav -->
<script>
  new lfl.ui.ScrollNav({});
  new lfl.cloud.GlobalProductMenu();
</script>

<script>new cloud.SocialFeeds(document.getElementById('feeds'));</script>



  <div id="maia-signature"></div>
  <div id="maia-footer">

    <!-- maia-footer-local -->
    <div id="maia-footer-local">
      <div class="maia-aux">

          <div class="ent-footer-top">
  <div class="g-plus-wrapper">
    <div class="g-plusone" data-href="http://cloud.google.com"></div>
  </div>
  <div class="g-plus-link"><a href="https://plus.google.com/+googlecloudplatform" rel="publisher">Google+</a></div>
  <div class="search">
    <form onsumbit="return false;" class="maia-search">
    <input name="q" placeholder="Search this site" type="text">
    <input name="hl" type="hidden" value="">
    <input name="q" type="hidden" value="site:cloud.google.com/">
    <button class="maia-button" event="autotrack-data-g" data-g-event="Footer" data-g-action="Site Search" data-g-label="Submit">
      <span class="maia-search-icon">Search</span>
    </button>
    </form>
  </div>

</div>

<div class="ent-footer-links">
  <div class="ent-footer-unit">
    <h4><a href="/es/why-google/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Why Google">Why Google</a></h4>
    <ul>
      <li><a href="/es/why-google/#infrastructure" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Infrastructure">Infrastructure</a></li>
      <li><a href="/es/why-google/#product" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Product">Product</a></li>
      <li><a href="/es/why-google/#services" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Services">Services</a></li>
      <li><a href="/es/why-google/#scalability" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Scalability">Scalability</a></li>
      <li><a href="/es/why-google/#performance" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Performance">Performance</a></li>
      <li><a href="/es/why-google/#support" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Support">Support</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/es/products/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Products">Products</a></h4>
    <ul>
      <li><a href="/es/products/app-engine/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="App Engine">App Engine</a></li>
      <li><a href="/es/products/compute-engine/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Compute Engine">Compute Engine</a></li>
      <li><a href="/es/products/cloud-storage/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Storage">Cloud Storage</a></li>
      <li><a href="/es/products/cloud-sql/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud SQL">Cloud SQL</a></li>
      <li><a href="/es/products/cloud-datastore/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Datastore">Cloud Datastore</a></li>
      <li><a href="/es/products/bigquery/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="BigQuery">BigQuery</a></li>
      <li><a href="/es/products/prediction-api/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Prediction API">Prediction API</a></li>
      <li><a href="/es/products/translate-api/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Translate API">Translate API</a></li>
      <li><a href="/es/products/cloud-endpoints/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Endpoints">Cloud Endpoints</a></li>
      <li><a href="/es/products/calculator/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing Calculator">Pricing Calculator</a></li>
      <li><a href="/pricing/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing">Pricing</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/es/solutions" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Solutions">Solutions</a></h4>
    <ul>
      <li><a href="/es/solutions/mobile/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Mobile">Mobile</a></li>
      <li><a href="/es/solutions/gaming/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Gaming">Gaming</a></li>
      <li><a href="/es/solutions/hadoop/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Hadoop">Hadoop</a></li>
      <li><a href="/solutions/mongodb/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="mongodb">mongodb</a></li>
      <li><a href="/solutions/rabbitmq/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="rabbitmq">RabbitMQ</a></li>
      <li><a href="/solutions/cassandra/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="cassandra">Cassandra</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/es/customers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Customers" data-g-label="Customers">Customers</a></h4>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/es/developers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Developers">Developers</a></h4>
    <ul>
      <li><a href="/es/developers#documentation" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Documentation">Documentation</a></li>
      <li><a href="/es/developers#resources" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Resources">Resources</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/es/support/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Support">Support</a></h4>
    <ul>
      <li><a href="https://support.google.com/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Platform Support Help Center">Platform Support Help Center</a></li>
      <li><a href="https://support.google.com/cloudbilling/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Billing Help Center">Billing Help Center</a></li>
      <li><a href="https://enterprise.google.com/supportcenter" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Enterprise Support Center">Google Enterprise Support Center</a></li>
    </ul>

  </div>


  <div class="ent-footer-unit">
    <h4><a href="/partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Partners">Partners</a></h4>
    <ul>
      <li><a href="/partners/technology-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Technology Partner">Technology Partners</a></li>
      <li><a href="/partners/service-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Service Partner">Find a Service Partner</a></li>
    </ul>
  </div>

  </div>
  <br class="clear" />

  </div>
  </div>
    <!-- /maia-footer-local -->

    <!-- maia-footer-global -->
    <div id="maia-footer-global">
      <div class="maia-aux">
        <ul>
          <li><a href="http://www.google.com/">Google</a></li>
          <li><a href="https://developers.google.com/readme/terms">Terms of Service</a></li>
          <li><a href="https://www.google.com/intl/es/policies/privacy/">Privacy Policy</a></li>
        </ul>
      </div>
    </div>
  </div>
  <!-- /maia-footer-global -->
  <script src="//www.google.com/js/maia.js"></script>
  <script type="text/javascript" async defer src="//www.gstatic.com/feedback/api.js"></script>
  <script id="jqueryui" src="//ajax.googleapis.com/ajax/libs/jqueryui/1.8.10/jquery-ui.min.js"></script>
  </body>
</html>
