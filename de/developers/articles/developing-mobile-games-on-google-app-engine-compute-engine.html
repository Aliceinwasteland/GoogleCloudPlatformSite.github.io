---
layout: de-phase2
title: Cloud Computing &amp; Cloud Hosting Services
---
<!DOCTYPE html>
<html devsite="">
<head>
<title>Mobile Articles &amp; Mobile Development Guides — Google Cloud Platform</title>
<meta name="description" content="Read technical articles on mobile solutions with Google Cloud Platform. Mobile specific articles cover application development, mobile backend and mobile gaming.">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/css/cp-ie.css'>
    <![endif]-->
<script src="/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Unternehmen, die die Google Cloud Platform nutzen</h1>
</div>
<div class="cp-article-tutorial">
<h1>Einführung</h1>
<p>Der mobile Spielemarkt wächst rasant und wird bis 2016 voraussichtlich einen Umsatz von 16&nbsp;Milliarden&nbsp;$ erreichen<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup>. Im vierten Quartal 2012 überschritten die globalen Ausgaben für Spiele auf der iOS-Plattform von Apple und auf der Android-Plattform von Google die Ausgaben für mobile Spielekonsolen<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup>.</p>
<p>Das Umsatzmodell bei mobilen Spielen verlagert sich von kostenpflichtigen Spielen hin zu kostenlosen Spielen, bei denen Erlöse aus virtuellen Gütern, anderen In-Game-Käufen und In-Game-Werbung erzielt werden. Im Zuge dieser neuen Trends sollen die mobilen Spiele interaktiver und immersiver werden.</p>
<p>Solche Spiele erfordern nicht nur attraktive Nutzererfahrungen auf dem Client, sondern auch funktionsreiche und skalierbare Back-End-Dienste. In diesem Artikel wird dargestellt, wie Sie mit der Google Cloud Platform auf einfache Weise ein mobiles Spiele-Back-End erstellen können.</p>
<h2>Umfang</h2>
<p>Dieses Dokument ist für Softwarearchitekten und -entwickler bestimmt, die es sich zum Ziel gesetzt haben, ihre eigenen mobilen Spiele-Back-Ends zu erstellen und die Interaktionsmuster zwischen mobilen Clients und dem Back-End zu entwerfen.</p>
<p>Herangehensweise und Architektur, die in diesem Dokument vorgestellt werden, sind auf die Neuentwicklung eines typischen mobilen Spiels anwendbar. Es gibt jedoch zwei Alternativen, die je nach Szenario und Anforderungen anwendbar sind. Die erste ist der <a href="https://developers.google.com/samples/mbs/">Mobile Backend Starter</a>, den Sie in Betracht ziehen können, wenn Sie es vorziehen, <a href="https://developers.google.com/samples/mbs/">ohne Entwicklung eines eigenen mobilen Spiele-Back-Ends loszulegen</a>. Bei der zweiten handelt es sich um die Architektur einer <a href="/resources/articles/dedicated-server-gaming-solution">Spielelösung mit dedizierten Servern</a>, die Sie in Erwägung ziehen können, wenn für Ihr mobiles Spiel der Einsatz dedizierter Spieleserver erforderlich ist.</p>
<p>Das vorliegende Dokument behandelt die Entwicklung hochskalierbarer neuer mobiler Spiele auf der Google Cloud Platform. Dabei wird die <a href="/de/developers/articles/mobile-application-solutions">hier</a> veröffentlichte Referenzarchitektur für mobile Lösungen angewendet und weitere Details und Beispiele speziell für die Erstellung mobiler Spiele werden aufgeführt. Zu dem Artikel gibt es eine Beispielanwendung für ein mobiles Spiel mit vollständigem Quellcode.</p>
<p>Die Erstellung des Clientteils von mobilen Spielen wird in diesem Dokument nicht behandelt. Allerdings enthält das Dokument einige grundlegenden Informationen in Bezug auf die Kommunikation mit den mobilen Spiele-Back-Ends, die Authentifizierung von Nutzern und das Senden von Push-Benachrichtigungen.</p>
<h2>Anforderungen</h2>
<p>Typische Anforderungen für ein mitreißendes mobiles Spiel sind unter anderem:</p>
<ol>
<li>Spielfunktionen:
<ul>
<li>Dynamische Spielinhalte</li>
<li>Außerhalb der Geräte gespeicherte Spieldaten</li>
<li>Bestenliste</li>
<li>Mehrspielermodus</li>
<li>Spielerzuordnung</li>
<li>Erstellung von Spielfeldern</li>
<li>Server-Website-Bots</li>
</ul>
</li>
<li>Plattform-Funktionen:
<ul>
<li>Unterstützung für Android- und iOS-Geräte über native Clientanwendungen</li>
<li>Push-Benachrichtigungen auf Android- und iOS-Geräte</li>
<li>Nutzerauthentifizierung</li>
<li>Hohe Skalierbarkeit</li>
</ul>
</li>
<li>Geschäftsfunktionen:
<ul>
<li>In-Game-Käufe</li>
<li>Spielanalyse</li>
</ul>
</li>
</ol>
<p>Wenn Sie Ihr mobiles Spiel auf der Google Cloud Platform erstellen, können Sie diese Anforderungen erfüllen.</p>
<h1>Architektur für mobile Spielelösungen</h1>
<p>Im folgenden Diagramm (Abb.&nbsp;1) ist die übergeordnete Architektur für mobile Spiele auf der Google Cloud Platform dargestellt:</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/architecture-diag.jpg" alt="">
<figcaption>Abbildung 1. Architekturdiagramm der vorgeschlagenen mobilen Spielelösung</figcaption>
</figure>
<h3>Gesamtübersicht</h3>
<p>Die vorgeschlagene Lösungsarchitektur umfasst folgende Hauptkomponenten:</p>
<ul>
<li>Mobiler Spieleclient – eine beliebige Kombination aus Android-, iOS- und HTML/JavaScript-Anwendungen</li>
<li>Mobile Spiele-Back-End-Anwendung</li>
<li>Kommunikationsebene zwischen den mobilen Spieleclients und Ihrem mobilen Back-End</li>
<li>Mehrere Cloud-Dienste für die Speicherung der Spieledaten und -bilder, für die Übermittlung von Push-Benachrichtigungen usw.</li>
</ul>
<h3>Die Funktionen der Hauptkomponenten</h3>
<p>Eine der Designentscheidungen besteht in der Festlegung, welche Funktionalität ihres mobilen Spiels von den einzelnen Komponenten der Lösung übernommen werden soll. Insbesondere geht es darum, welche Funktionalität in Ihrer Clientanwendung umgesetzt und welche Funktionen durch das mobile Spiele-Back-End implementiert und von den Cloud-Diensten bereitgestellt werden sollen.</p>
<p>Da Smartphones und Tablets immer leistungsfähiger werden, ist es zweckmäßig, so viele Funktionen wie möglich in den Spieleclients zu implementieren. Die hauptsächliche Funktion des mobilen Back-Ends besteht darin, die Gesamterfahrung zu bereichern, sie interaktiver und immersiver zu gestalten und Funktionalität bereitzustellen, die nur mit einer Clientanwendung allein nicht möglich wäre.</p>
<p>Viele beliebte mobile Spiele nutzen mobile Back-Ends für folgende Zwecke:</p>
<ul>
<li>Bereitstellung dynamischer Spielinhalte</li>
<li>Realisierung von Multiplayer-Spielen einschließlich der Zuordnung von Spielern</li>
<li>Speicherung von Daten außerhalb des mobilen Gerätes, z.&nbsp;B. das letzte abgeschlossene Level oder die in den vorherigen Spielen erreichten Ergebnisse</li>
<li>Verwaltung der Bestenliste</li>
<li>Orchestrierung der Push-Benachrichtigungen</li>
<li>Realisierung von In-Game-Käufen</li>
<li>Bereitstellung von Spielestatistiken</li>
</ul>
<h3>Mobiles Spiele-Back-End<sup><a href="#ftnt3" name="ftnt_ref3" id="ftnt_ref3">[3]</a></sup> in der Cloud</h3>
<p>Wenn Sie die Google Cloud Platform zum Betreiben Ihres mobilen Spiels verwenden, können Sie das Spiele-Back-End in Google App Engine ausführen, einer Plattform, die von <a href="/de/solutions/gaming">zahlreichen erfolgreichen Onlinespielen</a> genutzt wird, die von <a href="/de/customers/#cp-mobile">kleinen und großen Unternehmen</a> entwickelt wurden. Damit profitieren Sie von den folgenden Vorteilen der Google-Infrastruktur:</p>
<ul>
<li><a href="https://developers.google.com/appengine/whyappengine#scale">Automatische</a> <a href="https://developers.google.com/appengine/whyappengine#scale">Skalierbarkeit</a></li>
<li><a href="https://developers.google.com/appengine/docs/whatisgoogleappengine#The_Application_Environment">Automatischer Lastenausgleich über mehrere Instanzen des mobilen Back-Ends</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/appconfig#Static_Files_and_Resource_Files">Statische Bereitstellung von Inhalten und statisches Caching</a></li>
<li><a href="http://developers.google.com/appengine/whyappengine#reliable">Zuverlässigkeit, Leistungsstärke und Sicherheitsfunktionen</a></li>
<li><a href="http://developers.google.com/appengine/docs/adminconsole/index">Überwachung und Verwaltung</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/dos?hl=en">Konfigurierbarer DoS-Schutz</a></li>
<li><a href="https://developers.google.com/appengine/docs/python/endpoints/auth">Integration mit Google-Konten für die OAuth2-Authentifizierung (sowohl für Android- als auch iOS-Clients</a>)</li>
</ul>
<h1>Mobiles Spiel auf der Google Cloud Platform entwickeln</h1>
<h2>Beispielhaftes Spieleszenario</h2>
<p>Die in diesem Dokument beschriebene Architektur ist auf viele mobile Spiele anwendbar. Das unten dargestellte Beispielszenario dient in erster Linie dazu, das Design spezifischer zu gestalten. Die meisten der behandelten Designentscheidungen treffen auch auf andere mobile Spiele zu.</p>
<h3>Griddler – mobiles Rätselspiel für mehrere Spieler</h3>
<p>Gehen wir einmal davon aus, dass Sie ein mobiles Quiz- oder Rätselspiel für mehrere Spieler namens Griddler kreieren möchten. Zwei oder mehr Spieler treten gegeneinander an, um innerhalb einer vorgegebenen Zeit so viele Rätsel wie möglich zu lösen. Dieser Wettstreit wird als Spiel bezeichnet. Jedem Spieler wird eine Buchstabenmatrix gezeigt, zum Beispiel:</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/griddler.png" height="195" width="196" alt="">
<figcaption>Abbildung 2. Griddler-Screenshot</figcaption>
</figure>
<p>Jedem Spieler wird die gleiche Abfolge an Rätseln für eine bestimmte Matrix gestellt. Beispiel für ein erstes Rätsel:</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/sample-q.png" height="396" width="222" alt="">
<figcaption>Abbildung 3. Beispielfrage in Griddler</figcaption>
</figure>
<p>Die einzelnen Spieler müssen die Antwort herausfinden und dann mit einer Fingerbewegung das richtige Wort aus angrenzenden Buchstaben auf der Matrix bilden, wie in Abbildung&nbsp;4 gezeigt.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/answ-entry-griddler.png" height="396" width="222" alt="">
<figcaption>Abbildung 4. Antworteingabe in Griddler</figcaption>
</figure>
<p>Wenn ein Spieler das richtige Wort gefunden hat oder sich entscheidet, ein bestimmtes Rätsel zu überspringen, wird ihm ein anderes Rätsel für dieselbe Matrix präsentiert, wie in Abbildung&nbsp;5 gezeigt.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/riddle-griddler.png" height="396" width="222" alt="">
<figcaption>Abbildung 5. Ein weiteres Beispielrätsel in Griddler</figcaption>
</figure>
<p>Die Spieleclients rufen die Spielfelddefinition zu Beginn eines jeden Spiels vom mobilen Back-End ab. Auf diese Weise können neue Spielfelder und Rätsel hinzugefügt werden, ohne Clientanwendungen zu aktualisieren. Die Abfolge der Rätsel für ein bestimmtes Spielfeld kann zufällig oder fest sein. Die abgerufene Spielfelddefinition beinhaltet die Rätsel für das Spielfeld zusammen mit dem Zeitkontingent für ein bestimmtes Spiel. Wenn das Zeitkontingent erreicht wurde, gewinnt der Spieler, der die meisten Rätsel gelöst hat. Bei Gleichstand gewinnt der Spieler, der die Rätsel am schnellsten löste.</p>
<p>Es können zu beliebigen Zeitpunkten Millionen von Spielrunden gespielt werden, an denen jeweils 1 bis N Spieler teilnehmen. Zusätzlich verfügt Griddler über einen Einzelspielermodus, der zum Üben genutzt werden kann, oder einfach, um für sich alleine Rätselspaß zu haben.</p>
<p>Neben der Bereitstellung von Spielfelddefinitionen für die Clients ist das Back-End für Folgendes zuständig:</p>
<ul>
<li>Verwaltung der Spielerlisten und -statistiken, zum Beispiel, wie viele Spiele ein Spieler auf verschiedenen Geräten spielte und wie viele Multiplayer-Spiele er gewann</li>
<li>Verwaltung der Liste der Geräte, die von den Spielern verwendet wurden, damit Push-Benachrichtigungen an diese Geräte gesendet werden können</li>
<li>Senden von Spieleinladungen für Multiplayer-Spiele</li>
<li>Weiterleitung von Annahmen, Ablehnungen und Absagen von Einladungen</li>
</ul>
<h2>Hauptkomponenten mobiler Spielelösungen</h2>
<p>Griddler und andere mobile Spiele können auf einfache Weise auf der in diesem Dokument beschriebenen Architektur implementiert werden. Die Clients können als native iOS- und Android-Anwendungen implementiert werden. Das mobile Spiele-Back-End kann in Google App Engine ausgeführt werden. Google Cloud Endpoints können verwendet werden, um eine API aus dem mobilen Back-End freizugeben und diese API auf den Clients zu nutzen.</p>
<h3>Clientanwendungen für mobile Spiele</h3>
<p>Die Android- und iOS-Clientanwendungen sind für die gesamte Benutzeroberfläche und alle Nutzerinteraktionen des Spiels sowie für die Spielemechanik zuständig. Das Design für diese Funktionalität unterschiedet sich kaum vom Design eines mobilen Spiels, bei dem kein mobiles Spiele-Back-End verwendet wird, und wird deshalb im Rahmen dieses Dokuments nicht behandelt.</p>
<p>Ein Unterschied besteht jedoch darin, dass die Griddler-Clients von einem mobilen Spiele-Back-End betrieben werden. Die Clients kommunizieren mit dem Back-End, um Spiele im Mehrspielermodus und die Zuordnung von Spielern zu ermöglichen. Dies schließt die Verarbeitung empfangener Push-Benachrichtigungen bei Spieleinladungen ein, die vom Back-End versendet werden. Der Client ruft auch dynamische Spielinhalte vom Back-End ab, zum Beispiel Spielfelddefinitionen für bestimmte Spiele. Dazu gehören die Buchstabenmatrix und alle Rätsel für eine bestimmte Matrix sowie die gültigen Lösungen für diese Rätsel.</p>
<p>Sobald ein Spiel gestartet wurde, muss der Client unabhängig davon, ob es sich um ein Spiel im Einzelspieler- oder Mehrspielermodus handelt, vor Ende des Spiels nicht mehr mit dem Back-End kommunizieren. Anschließend übermittelt der Client die Spielergebnisse an das mobile Spiele-Back-End und das Back-End speichert die Ergebnisse und bestimmt, wer zum Beispiel ein Spiel mit mehreren Spielern gewonnen hat.</p>
<h3>Mobiles Spiele-Back-End</h3>
<p>Das mobile Spiele-Back-End muss die entsprechende API für den Client freischalten, um die gewünschte Spielemechanik und Nutzererfahrung freizugeben.</p>
<p>Die Griddler API beinhaltet Methoden für folgende Elemente:</p>
<ul>
<li>Spielemanagement, zum Beispiel startNewSinglePlayerGame (ruft u.&nbsp;a. eine Spielfelddefinition ab) und gameFinished</li>
<li>Einladungen an Spieler, zum Beispiel sendInvitation, acceptInvitation usw.</li>
<li>Benachrichtigungen, zum Beispiel registerDeviceForPushNotification</li>
</ul>
<p>Diese Methoden können laut Beschreibung im <a href="#cbym">nächsten Abschnitt</a> für die Clients freigeschaltet werden.</p>
<p>Bei der Verarbeitung synchroner API-Anfragen übernimmt das mobile Back-End <a href="#storedata">Speicherung, Abruf und Verwaltung der Daten in einem persistenten Speicher</a>. Im Falle von Daten, auf die häufig zugegriffen wird, zum Beispiel Spielfelddefinitionen, nutzt es auch den <a href="#odawm">Speichercache</a>.</p>
<p>Neben der Abwicklung von Clientanfragen ist das mobile Back-End für die <a href="#odawm">asynchrone Verarbeitung</a> zuständig, die für das mobile Spiel, die <a href="#pushnotifications">Orchestrierung von Push-Benachrichtigungen</a>, die Handhabung <a href="#scheduled">geplanter Aufgaben</a> und so weiter benötigt wird.</p>
<a name="cbym" id="cbym"></a>
<h3>Kommunikation zwischen den mobilen Spieleclients und dem mobilen Spiele-Back-End</h3>
<p>Wie im <a href="/de/developers/articles/mobile-application-solutions">Artikel "Mobile Lösungen"</a> ausgeführt, wird die Verwendung von <a href="https://developers.google.com/appengine/docs/java/endpoints/overview">Google Cloud Endpoints</a><sup><a href="#ftnt4" name="ftnt_ref4" id="ftnt_ref4">[4]</a></sup> empfohlen, um eine API aus dem mobilen Back-End freizuschalten und auf dem mobilen Client zu verarbeiten. Mit diesem Verfahren können Sie Ihre API über einfache Annotationen im Quellcode definieren und Tools für die Generierung stark typisierter Android- und iOS-Clientbibliotheken nutzen sowie JavaScript-Code für die Interaktion mit der API aus den Webclients. Dieses Vorgehen unterstützt auch die OAuth2-basierte Authentifizierung mit Google-Konten, damit die Identität des Spielers im Back-End-Code des mobilen Spiels hinterlegt ist.</p>
<p>In Griddler ist die Methode zum Senden einer Einladung beispielsweise wie folgt deklariert:</p>
<pre>
@ApiMethod(httpMethod = "PUT", path ="game/{gameId}/invitation/{playerId}")
public InvitationResult sendInvitation(@Named("gameId") Long gameId,
 @Named("playerId") Long playerId, User user) throws ServiceException { }
</pre>
<p>Mit dem obigen Code wird eine sendInvitation API deklariert, die bei der Übertragung als HTTP PUT-Anfrage unter Verwendung der im Pfadargument angegebenen URL dargestellt wird. Die gameId- und playerId-Argumente werden vom Client explizit übergeben. Das Nutzerobjekt wird über die Google Cloud Endpoints-Infrastruktur konfiguriert, die auf den vom Client implizit gelieferten Authentifizierungsinformationen basiert. <a href="https://developers.google.com/appengine/docs/java/endpoints/annotations"></a><a href="https://developers.google.com/appengine/docs/java/endpoints/annotations">Weitere Informationen über die @Api-Annotation finden Sie in der Cloud Endpoints-Dokumentation</a>.</p>
<p>Wenn die Cloud Endpoints-Tools zur Generierung von Clientbibliotheken eingesetzt werden, kann der Android-Client diese aus dem mobilen Back-End freigegebene API einfach wie folgt aufrufen:</p>
<pre>
InvitationResult invitationResult = gameBackend.sendInvitation(
gameId, playerId)).execute();
</pre>
<p>Ein solcher Aufruf sollte in der Regel asynchron erfolgen, um eine Blockierung von Netzwerkaufrufen im Benutzeroberflächen-Thread zu vermeiden.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/communication.png" height="341" width="579" alt="">
<figcaption>Abbildung 6. Kommunikation zwischen dem mobilen Spieleclient und dem Spiele-Back-End</figcaption>
</figure>
<a name="storedata" id="storedata"></a>
<h3>Daten speichern<sup><a href="#ftnt5" name="ftnt_ref5" id="ftnt_ref5">[5]</a></sup></h3>
<p>Mobile Spiele, die interaktiv und immersiv sind, müssen Daten in der Regel außerhalb der Clientgeräte speichern.</p>
<p>Für manche mobile Spiele ist die Nutzung dynamischer Inhalte wünschenswert, die als große und typischerweise binäre Objekte repräsentiert werden. Dazu gehören Bilder, die Teile einer virtuellen Spielewelt definieren, oder Avatare, die von den Spielern hochgeladen werden. Für diese Art von Daten können Sie <a href="http://developers.google.com/storage/docs/getting-started">Google Cloud Storage</a> nutzen, einen Dienst, der Objekte und Dateien bis zu Terabytegröße speichern kann. Siehe auch <a href="#sapi">Bilder bereitstellen und verarbeiten</a> weiter unten.</p>
<p>Bei den anderen Datentypen, die außerhalb der Clientgeräte gespeichert werden müssen, handelt es sich um detaillierte Eigenschaften und Entitäten. Diese Eigenschaften und Entitäten können Informationen über den höchsten abgeschlossenen Level in einem mobilen Spiel und weitere Informationen über Spieler umfassen, zum Beispiel ihre Nicknames, die Registrierung von Spielergeräten für Push-Benachrichtigungen, Erfassung ihrer In-Game-Käufe und sonstige spielspezifische Daten.</p>
<p>Die Eigenschaften dieser Entitäten können auch Verweise auf in Google Cloud Storage gespeicherte Objekte beinhalten, zum Beispiel den Objektnamen und – optional – einen Bucket-Namen oder eine URL.</p>
<p>Wenn Ihr mobiles Back-End in Google App Engine gehostet wird, wird <a href="https://developers.google.com/datastore/">Cloud Datastore</a> als Speicherplatz für solche Entitäten empfohlen. Dabei handelt es sich um einen schemalosen, hochskalierbaren NoSQL-Objektdatenspeicher<sup><a href="#ftnt6" name="ftnt_ref6" id="ftnt_ref6">[6]</a></sup> mit einer Abfrage-Engine und atomischen Transaktionen.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/storing-data.jpg" height="350" width="305" alt="">
<figcaption>Abbildung 7. Daten speichern</figcaption>
</figure>
<p>Die Hauptentitäten in Griddler sind zum Beispiel:</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/key-entities.jpg" alt="">
<figcaption>Abbildung 8. In Griddler verwendete Hauptentitäten</figcaption>
</figure>
<ul>
<li>Player (Spieler)</li>
<li>Board (Spielfeld) – Definition einer Spielematrix und der Rätsel für diese Matrix</li>
<li>Game (Spiel) – Instanz aus einem oder mehreren Spielern, die bei der Lösung von Rätseln auf einem vorgegebenen Spielfeld gegeneinander antreten</li>
<li>Invitation (Einladung) – Entität zur Initiierung von Multiplayer-Spielen</li>
<li>GamePlay – Entität, die Status und Ergebnisse eines Spielers in einem Spiel darstellt. Bei Multiplayer-Spielen sind für ein Spiel viele GamePlay-Entitäten vorhanden, d.&nbsp;h. eine pro Spieler.</li>
<li>Device (Gerät) – plattformspezifische Informationen, die für das Senden von Push-Benachrichtigungen an ein bestimmtes Gerät benötigt werden, z.&nbsp;B. Geräte-Token für iOS und GCM-Registrierungs-ID für Android</li>
</ul>
<p>Aus Konsistenzgründen gehören "Invitation" und "GamePlay" zur <a href="https://developers.google.com/appengine/docs/java/gettingstarted/usingdatastore?hl=en">Entitätsgruppe</a> im Root der Ancestor-Entität "Game". Entsprechend gehört die Entität "Device" zur Entitätsgruppe im Root der Ancestor-Entität "Player".</p>
<p>Wenn Sie den Datenspeicher zur Speicherung der Entitäten nutzen, können Ihre mobilen Spiele problemlos für Millionen von Spielern skaliert werden.</p>
<p>Da Griddler in der aktuellen Implementierung keine binären Daten oder große Datenmengen nutzt, werden alle Daten im Datenspeicher hinterlegt. Wenn jedoch Erweiterungen für visuelle Lösungshinweise bei Rätseln oder für das Hochladen von Avataren für Spieler implementiert werden, könnte man bei Griddler für das Speichern von Bildern Google Cloud Storage verwenden.</p>
<a name="odawm" id="odawm"></a>
<h3>Datenzugriff mit Memcache optimieren</h3>
<p>Im Zuge steigender Auslastung kann Ihr mobiles Spiele-Back-End Tausende einzelner Instanzen umfassen, die Anfragen verarbeiten. Wenn Ihre mobilen Spieleclients häufige Anfragen an das Back-End zum Abruf derselben Daten stellen, kann der Datenzugriff optimiert werden, um den Abruf von Daten aus dem persistenten Speicher für jede Anfrage zu vermeiden.</p>
<p>Ein Back-End, das in Google App Engine ausgeführt wird, kann einen verteilten speicherinternen Datencachedienst namens <a href="http://developers.google.com/appengine/docs/java/memcache/">Memcache</a> zum Speichern und Abrufen von Daten verwenden, auf die häufig zugegriffen wird (Abb.&nbsp;9). Die Verwendung von Memcache ermöglicht nicht nur eine höhere Leistung und bessere Skalierung des mobilen Spiele-Back-Ends, sondern senkt auch die Kosten für den Zugriff auf den App Engine-Datenspeicher, da Ihre Anwendung weniger Anfragen an den Datenspeicher sendet.</p>
<p>Es kann beispielsweise eine Situation eintreten, wo Millionen Personen gleichzeitig Griddler spielen und Hunderttausende Spieler zur gleichen Zeit Rätsel aus demselben Spielfeld (Buchstabenmatrix) lösen. Anstatt die Spielfelddefinitionen jedes Mal abzurufen, ist es sinnvoller, sie zwischenzuspeichern.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/optimizing-data.jpg" height="421" width="352" alt="">
<figcaption>Abbildung 9. Datenzugriff mit Memcache optimieren</figcaption>
</figure>
<h3>Asynchrone Verarbeitung mit Aufgabenwarteschlangen</h3>
<p>Gelegentlich ist es nicht möglich oder wünschenswert, alle Aufgaben im Zusammenhang mit einer von einem mobilen Spieleclient empfangenen Anfrage zu erledigen, bevor die Antwort zurück an das Gerät des Nutzers gesendet werden muss.</p>
<p>Im Sinne einer interaktiveren und gemeinschaftlicheren Spielerfahrung könnte Griddler zum Beispiel mit einer Funktion ausgestattet werden, um die Freunde eines Spielers zu benachrichtigen, wenn der Spieler eine sehr hohe Punktzahl erreicht und es auf die Bestenliste schafft. Diese Funktion könnte ausgelöst werden, wenn der Client die gameFinished API aufruft. Es ist jedoch zu berücksichtigen, dass ein Spieler viele Freunde haben kann und der Client nicht blockiert werden sollte, bis alle Freunde benachrichtigt wurden. Ein solches synchrones Design würde nicht nur den Client blockieren, sondern wäre auch unzuverlässig. Stattdessen kann Ihr mobiles Spiele-Back-End als Teil der gameFinished API die Spielresultate speichern, die Notwendigkeit zur Verarbeitung von Benachrichtigungen erfassen und die Antwort sofort an den Client zurücksenden, ohne zu warten, bis alle Benachrichtigungen verarbeitet wurden.</p>
<p>Ihr Code, der in Google App Engine ausgeführt wird, kann einen Dienst namens <a href="http://developers.google.com/appengine/docs/java/taskqueue/">Task Queues</a> (Aufgabenwarteschlange) nutzen, um Informationen über die asynchron durchzuführenden Aufgaben in die Warteschlange zu stellen. Im zuvor beschriebenen Beispiel könnte Ihre Anwendung eine Aufgabe zur Benachrichtigung der Freunde des Spielers in die Warteschlange aufnehmen, die besagt, dass der Spieler jetzt zu den 20 besten Spielern gehört.</p>
<p>Typischerweise würden Sie den Dienst "Task Queues" so konfigurieren, dass die Aufgaben in der Warteschlange (<a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-push">Push-Modell</a>) als HTTP-Anfragen auf eine ausgewählte URL an den Code gesendet werden, der in Google App Engine ausgeführt wird. Im obigen Beispiel könnte der Anfragen-Handler die Aufgabendaten aus der HTTP-Anfrage abrufen, nach den Freunden des Spielers suchen und dann die einzelnen Freunde benachrichtigen, indem entweder in einem sozialen Netzwerk Posts im Namen des Spielers erstellt oder Push-Benachrichtigungen gesendet werden, <a href="#pushnotifications">wie unten beschrieben</a>.</p>
<p>Alternativ können Sie mit dem mobilen Back-End-Code die <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">Aufgaben</a> <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">aus der oder den Warteschlangen abrufen</a>. Dies ist möglicherweise nützlich, wenn Sie die Verarbeitung von Aufgaben explizit steuern möchten. Ein anderes Szenario für einen sinnvollen Einsatz von Pull-Aufgaben wäre, wenn Sie die Aufgaben außerhalb von App Engine verarbeiten möchten, zum Beispiel mit Google Compute Engine-Instanzen, so wie dies im <a href="/de/developers/articles/mobile-application-solutions">Artikel</a> <a href="/de/developers/articles/mobile-application-solutions">"Mobile</a> <a href="/de/developers/articles/mobile-application-solutions">Lösungen"</a> ausgeführt ist.</p>
<a name="pushnotifications" id="pushnotifications"></a>
<h3>Push-Benachrichtigungen</h3>
<p>Mithilfe von Push-Benachrichtigungen können Spiele-Back-Ends die Clients über Statusänderungen und andere relevante Ereignisse informieren, ohne dass die Clients fortwährend Abfragen vornehmen müssen. Push-Benachrichtigungen können für die Schaffung einer funktionsreichen Nutzererfahrung bei gleichzeitiger Optimierung der Akku- und Bandbreitennutzung verwendet werden. Abhängig von der Clientplattform kann Ihr mobiles Gerät diese Technologie zur Anzeige von <a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">Pop-up</a><a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">s</a> und anderen Benachrichtigungen auf den Geräten der Nutzer verwenden, auch wenn der mobile Spieleclient nicht aktiv ist. Sie können damit den mobilen Spieleclient auch weiter mit relevanten Daten versorgen.</p>
<p>In Griddler werden Push-Benachrichtigungen verwendet, um Einladungen zu senden, wenn ein Spieler einen Freund herausfordern möchte. Mithilfe von Push-Benachrichtigungen können Freunde eingeladen werden, auf deren Geräten das Spiel derzeit nicht ausgeführt wird.</p>
<p>Wenn der mobile Back-End-Code in Google App Engine ausgeführt wird, können Sie das Senden von Push-Benachrichtigungen an Ihre Nutzer über die Verwendung der folgenden Technologien orchestrieren:</p>
<ul>
<li><a href="http://developer.android.com/google/gcm/index.html">Google Cloud Messaging</a> für Android (GCM) – ein Google-Dienst, mit dem Sie Daten an Nutzer senden können, auf deren Android-Geräten die Clientanwendung Ihres mobilen Spiels installiert ist. Bei Verwendung von Eclipse können Sie die Rohfassung des Codes von <a href="http://developers.google.com/eclipse/">Google-Plug-in für Eclipse</a> erzeugen lassen.</li>
<li>Sockets API<sup><a href="#ftnt7" name="ftnt_ref7" id="ftnt_ref7">[7]</a></sup> zum Senden von Push-Benachrichtigungen mit dem Apple®-Push-Benachrichtigungsdienst an iOS-Nutzer. Lesen Sie für den Einstieg den <a href="/resources/articles/ios-push-notifications">Lösungsartikel über die Orchestrierung von iOS-Push-Benachrichtigungen auf der Google Cloud Platform</a> und befassen Sie sich mit dem <a href="https://github.com/GoogleCloudPlatform/solutions-ios-push-notification-sample-backend-java">auf Github veröffentlichten Beispielcode</a>.</li>
</ul>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/push-notification.png" height="438" width="457" alt="">
<figcaption>Abbildung 10. Push-Benachrichtigung</figcaption>
</figure>
<a name="sapi" id="sapi"></a>
<h3>Bilder bereitstellen und verarbeiten</h3>
<p>Manche statische Bilder, zum Beispiel diverse Symbole, die zu Ihrem Spiel gehören und für die Erstellung der Benutzeroberfläche der Clientanwendung verwendet werden, können – oftmals in mehreren Auflösungen – in die nativen Android- und iOS-Spieleclients gepackt werden. Allerdings wird das Paket so auch größer. Große Pakete können Nutzer vom Herunterladen Ihrer App abhalten oder dazu führen, dass die Nutzer diese eher deinstallieren, wenn der Speicherplatz auf ihren Geräten knapp wird.</p>
<p>Es ist oftmals nicht praktikabel oder möglich, alle für ein Spiel benötigten Bilder in eine Clientanwendung zu packen. So besitzt Ihr mobiles Spiel möglicherweise große und/oder dynamische virtuelle Welten mit umfangreichen Grafiken, was Bilddateien mit einer Gesamtgröße von Hunderten von Megabyte oder Gigabyte mit sich bringt. Aber auch, wenn Ihre Bilder nicht so groß sind, möchten Sie vielleicht in der Lage sein, neue Grafiken zu Ihrem Spiel hinzuzufügen, ohne die Nutzer zu zwingen, ihre Clientanwendungen zu aktualisieren.</p>
<p>Griddler könnte zum Beispiel für die Aufnahme einiger visueller Lösungshinweise für Rätsel erweitert werden. Eine Erweiterung könnte auch beinhalten, dass die Spieler Bilder für ihre Avatare hochladen können.</p>
<p>Sie können solche Bilder in für Ihre mobilen Spieleclients optimierten Auflösungen und Formaten vorbereiten, sie in <a href="http://developers.google.com/storage/docs/getting-started">Google Cloud Storage</a> hochladen und anschließend den mobilen Clients direkte URLs dieser Bilder liefern. Dieser Ansatz ermöglicht eine ausgezeichnete Skalierung, weil die mobilen Clients die Bilder direkt ohne Beteiligung des mobilen Back-End-Codes aus dem skalierbaren Cloud-Speicher abrufen können</p>
<p>In manchen Fällen ist zusätzlich zur Speicherung eine Be- und Verarbeitung von Bildern wünschenswert. Vielleicht möchten Sie die Bilder je nach Auflösung der Clientgeräte in dynamisch angepassten Größen bereitstellen. In solchen Fällen können Sie den Google App Engine-<a href="https://developers.google.com/appengine/docs/java/images/">Bilderdienst</a> für Größenänderung, Drehung, Spiegelung und Zuschneiden von Bildern sowie zur Verbesserung von Fotos anhand eines vordefinierten Algorithmus verwenden. Diese Operationen können mit Bildern aus Google Cloud Storage und anderen Quellen durchgeführt werden. Die modifizierten Bilder können dann aus der dynamischen Google-Infrastruktur für die Bereitstellung von Bildern ohne Beteiligung des Back-End-Codes Ihres mobilen Spiels direkt an die Clients übermittelt werden. Mit Ihrem Code wird lediglich die Verwendung der Images Service API für den Abruf der passenden Bild-URL und die Übermittlung dieser URL an die mobilen Spieleclients programmiert.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/serving-processing-imgs.jpg" height="373" width="467" alt="">
<figcaption>Abbildung 11. Bilder bereitstellen und verarbeiten</figcaption>
</figure>
<a name="scheduled" id="scheduled"></a>
<h3>Geplante Aufträge</h3>
<p>Neben der synchronen Verarbeitung von Anfragen der mobilen Spieleclients über Google Cloud Endpoints und der asynchronen Nutzung der Aufgabenwarteschlangen hat der Back-End-Code Ihres mobilen Spiels möglicherweise noch einige Verarbeitungsaufgaben, die in verschiedenen regelmäßigen oder halbregelmäßigen Intervallen durchzuführen sind. Vielleicht möchten Sie mithilfe des mobilen Spiele-Back-Ends Push-Benachrichtigungen an Spieler senden, die Ihr Spiel seit einigen Tagen nicht mehr genutzt haben, und diese zum erneuten Spielen motivieren. Die entsprechenden Prozesse könnten dann zu bestimmten Tageszeiten durchgeführt werden.</p>
<p>Möglicherweise soll Ihr mobiles Spiele-Back-End auch einige Daten im Memcache-Zwischenspeicher alle 5&nbsp;Minuten aktualisieren oder alle 15&nbsp;Minuten Statistiken zu Spitzenspielern aktualisieren.</p>
<p>Wenn der Back-End-Code Ihres mobilen Spiels in Google App Engine ausgeführt wird, ist die Konfiguration solcher planmäßigen Aufträge mit dem <a href="http://developers.google.com/appengine/docs/java/config/cron">Cron-Dienst</a> problemlos möglich. Sie können den Dienst so einrichten, dass einige URLs in Ihrem mobilen Back-End zu den angeforderten Intervallen oder Zeiten aufgerufen werden.</p>
<figure><img src="/images/articles/developing-mobile-games-on-gcp/scheduled-jobs.jpg" height="282" width="412" alt="">
<figcaption>Abbildung 12. Geplante Aufträge mit Cron-Dienst</figcaption>
</figure>
<h2>Google Play-Spieldienste</h2>
<p>Eine einfache Möglichkeit zu einer interaktiveren Konzeption Ihrer Android-, iOS- und Webspiele besteht in der Verwendung der <a href="https://developers.google.com/games/services/">Google Play-Spieldienste</a>. Sie können Spieler mit bestimmten Leistungen belohnen, die Motivation mit Bestenlisten erhöhen und Ihr Spiel dynamischer gestalten, indem Sie mehrere Spieler simultan gegeneinander antreten oder kooperieren lassen.</p>
<h2>Beispielanwendungen</h2>
<p>Sie können die Beispielanwendung Griddler von <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">Github</a> herunterladen. Das mobile Back-End ist in Java implementiert und schaltet die REST API mithilfe Cloud Endpoints frei. Die Daten werden mit einer untergeordneten API im Datenspeicher abgelegt und Push-Benachrichtigungen werden versendet. <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client">Android</a>- und <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client">iOS</a>-Spieleclients werden als native Anwendungen implementiert. Die Kommunikation zwischen den Clients und dem mobilen Spiele-Back-End wird über OAuth und Google-Konten authentifiziert.</p>
<p>Sie können auch <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java">Cloud Adventure</a> herunterladen – ein anderes Beispiel für ein mobiles Spiel, das auf einer ähnlichen Architektur beruht. Cloud Adventure ist ein textbasiertes <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client">Android-Spiel</a>, das einige interessante Szenarien präsentiert, zum Beispiel eine Spiel-Lobby für mehrere Spieler und eine Auswahl einmaliger Nicknames. Mit dem Spiel wird ebenso demonstriert, wie eine Kombination aus Google Cloud Messaging für Android und Cloud Endpoints genutzt werden kann, um den Abschluss eines Spiels zu verwalten und die Ergebnisse zu ermitteln.</p>
<h2>Nächste Schritte</h2>
<p>Wenn nicht bereits geschehen, besuchen Sie das <a href="/">Google Cloud Platform-Portal</a> und klicken Sie auf den Link "Jetzt testen". Sie werden dann durch die Schritte zur Erstellung eines kostenlosen Google Cloud-Projekts geführt, das Sie verwenden können, um das Spielbeispiel Griddler <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">bereitzustellen</a>. Anschließend können Sie das Spiel ausprobieren, erkunden und versuchen, es zu erweitern, indem Sie beispielsweise zu jedem Rätsel einen visuellen Lösungshinweis hinzufügen.</p>
<h2>Fazit</h2>
<p>Mithilfe der Google Cloud Platform können Sie auf einfache Weise ein mobiles Back-End für Ihre Spiele erstellen. Sie können sich damit auf die Entwicklung Ihres Spiels konzentrieren und müssen sich nicht um Bereitstellung, Wartung und Fehlerbehebung der IT-Infrastruktur kümmern. Sie können überzeugende und mitreißende mobile Spiele kreieren, die übergangslos von einer Handvoll Nutzern zu Millionen von Spielern weltweit skaliert werden können.</p>
<p>Es gibt bereits viele <a href="/de/solutions/gaming">erfolgreiche Spiele</a>, die über die Google Cloud Platform betrieben werden, und wir können es gar nicht erwarten, Ihre Erfolgsgeschichten zu erfahren.</p>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> Siehe <a href="http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2">http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2</a>.</p>
<p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> Siehe <a href="http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8">http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8</a>.</p>
<p><a href="#ftnt_ref3" name="ftnt3" id="ftnt3">[3]</a> In diesem Dokument bezieht sich Back-End grob auf den Teil einer mobilen Lösung, der außerhalb der Clientgeräte ausgeführt wird. Der Begriff sollte nicht mit <a href="http://developers.google.com/appengine/docs/java/backends/overview?hl=en">Back-End-Instanzen</a> von Google App Engine verwechselt werden.</p>
<p><a href="#ftnt_ref4" name="ftnt4" id="ftnt4">[4]</a> Seit Juni 2013 ist Google Cloud Endpoints ein experimentelles Funktionsmerkmal.</p>
<p><a href="#ftnt_ref5" name="ftnt5" id="ftnt5">[5]</a> Abschnitt 4.2 der <a href="https://developers.google.com/appengine/terms">Google App Engine-Nutzungsbedingungen</a> beschreibt Ihre Verpflichtung zum Schutz der Privatsphäre und gesetzlichen Rechte Ihrer Endnutzer, einschließlich der Anforderung, eine rechtlich angemessene Datenschutzerklärung über die Nutzung der von Ihnen erfassten Daten bereitzustellen. Darüber hinaus wird Ihre Verpflichtung zur Einholung der notwendigen Einverständniserklärungen Ihrer Endnutzer bezüglich Erfassung, Nutzung, Überwachung und Offenlegung dieser Daten dargelegt.</p>
<p><a href="#ftnt_ref6" name="ftnt6" id="ftnt6">[6]</a> Wenn Sie die Nutzung einer relationalen SQL-Datenbank bevorzugen, können Sie sich für die Verwendung von <a href="http://developers.google.com/cloud-sql/">Google Cloud SQL</a> entweder <a href="http://developers.google.com/cloud-sql/faq#choice">anstelle oder zusätzlich zum Datenspeicher entscheiden</a>.</p>
<p><a href="#ftnt_ref7" name="ftnt7" id="ftnt7">[7]</a> Seit Juni 2013 ist die Sockets API eine experimentelle Funktion.</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">Feedback zu diesem Dokument</a><br>
<br>
<hr>
<h4>Beispielanwendungen</h4>
<ul>
<li>Mobiles Multiplayer-Spiel Griddler<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java" target="popout">[Java-Back-End]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client" target="popout">[Android-Client]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client" target="popout">[iOS-Client]</a> <img src="/images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
<li>Textbasiertes Android-Spiel Cloud Adventure<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java" target="popout">[Java-Back-End]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client" target="popout">[Android-Client]</a> <img src="/images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
</ul>
<hr></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'de',
        'region': 'emea',
        'language': 'de'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>