---
layout: phase2-ja
title: Cloud Computing &amp; Cloud Hosting Services
---
<!DOCTYPE html>
<html>
<head>
<title>Big Data Articles &amp; Tutorials - Google Cloud Platform — Google Cloud Platform</title>
<meta name="description" content="Google Cloud Platform では、Google の拡張性に優れたインフラストラクチャでアプリケーションやウェブサイトのビルドとホスティング、データの保存、データの分析を行えます。">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/css/cp-ie.css'>
    <![endif]-->
<script src="/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Compute Engine のディスク: 料金、パフォーマンス、永続性</h1>
</div>
<style>
.cp-table th, table td {
  padding: 4px 12px !important;
}

.blu-hdr th {
  color: #FFF;
  background-color: #6199df;
}
</style>
<div class="cp-article-tutorial ced-price-perf-persist">
<h2><a name="h.w3kz4fze562t" id="h.w3kz4fze562t"></a>はじめに</h2>
<p><a target="_blank" href="/compute/">Google Compute Engine</a> では、ソフトウェア サービスを構築するデベロッパーに軽快で信頼性が高く安価な計算能力を提供するよう努めています。ほとんどのアプリケーションでは、CPU やメモリだけでなく、高いパフォーマンスと信頼性を兼ね備えたブロック ストレージが必要です。Google Cloud Platform においてその役割を担うのが、Compute Engine <a target="_blank" href="https://developers.google.com/compute/docs/disks">永続ディスク</a>です。</p>
<p>永続ディスク用のハードウェア/ソフトウェア インフラストラクチャを構築するにあたり、Google では以下の点を最優先しました:</p>
<ul>
<li>セキュリティ</li>
<li>信頼性</li>
<li>一貫したパフォーマンス</li>
</ul>
<p>Google はこれまでに、大規模なデータセンターをいくつも開設してきました。その中で蓄積した経験を生かし、一貫性と信頼性という不可欠な性質を備えた永続ディスクを手頃な価格で提供いたします。ここでは、永続ディスクの概要について理解していただくため、これらの不可欠な性質とそのパフォーマンスについて解説します。</p>
<h2><a name="h.c4jyes8qkitc" id="h.c4jyes8qkitc"></a>Compute Engine の永続ディスク</h2>
<p>Compute Engine の永続ディスクは Compute Engine のインスタンスに対して、高速で信頼性の高い<a href="http://en.wikipedia.org/wiki/Storage_area_network">ストレージ エリア ネットワーク</a>（SAN）に非常に近い、ネットワークに接続されたブロック ストレージを提供します。</p>
<p>Google 永続ディスクの主な特長は次のとおりです:</p>
<ul>
<li>復元力</li>
<li>パフォーマンスの一貫性</li>
<li>暗号化</li>
<li>チェックサム</li>
</ul>
<p>さらに、永続ディスクではストレージがサービスとして提供されるので、管理しやすく、軽快に利用できます。</p>
<p>永続ディスクでは次のことが可能です</p>
<ul>
<li>インスタンスからの接続解除と新しいインスタンスへの再接続</li>
<li>グローバルにアクセス可能なスナップショットに簡単にコピー</li>
<li>読み取り専用モードで複数のノードに接続</li>
</ul>
<h3><a name="h.hblytow164l9" id="h.hblytow164l9"></a>主な特長</h3>
<h4><a name="h.k40zex5efw5h" id="h.k40zex5efw5h"></a>復元力</h4>
<p>永続ディスクには冗長性が組み込まれており、機器の障害からデータが保護され、データセンターのメンテナンス中でも利用が可能です。インスタンスにローカル ストレージが不要なため、<a href="https://developers.google.com/compute/docs/instances#schedulingoptions">Google Live Migration</a> を使用して新しいハードウェアに自動的に移行できます。この方法により Google データセンターのメンテナンスは最高水準に保たれており、ソフトウェア、ハードウェア、設備を継続的に更新することでクラウドベース サービスの高パフォーマンスと信頼性を実現しているのです。</p>
<h4><a name="h.p4063icl0ptv" id="h.p4063icl0ptv"></a>パフォーマンスの一貫性</h4>
<p>永続ディスクでは、単一のゾーン内の多数の物理ボリュームにデータをストライプ化して、パフォーマンスの一貫性を維持します。その結果、同じゾーン内の同じサイズのボリュームは一般に、いつでも同レベルのパフォーマンスで処理されます。ゾーンの IO の総合負荷が増減するにつれて、ボリュームのパフォーマンスは変わる可能性がありますが、多数の物理ボリュームにストライプ化することによりその変動は大幅に抑えられます。</p>
<h4><a name="h.t3xil3z2275e" id="h.t3xil3z2275e"></a>暗号化</h4>
<p>永続ディスクのデータは、仮想マシン インスタンス外では常に暗号化されます。インスタンスがディスクに書き込みを送信する際は、データを透過的に暗号化してからネットワークに送出します。インスタンスがディスクからデータを読み取る際は、ネットワークから返されたデータを復号化します。保存されるときでも、利用されるときでも、永続ディスクのデータは暗号化されています。</p>
<h4><a name="h.rwyp6l791mu5" id="h.rwyp6l791mu5"></a>チェックサム</h4>
<p>永続ディスクのすべての IO でチェックサムが計算されるため、読み取ったデータは書き込んだデータと必ず一致します。永続ディスクには冗長性が組み込まれており、格納したデータの冗長性が保証されています。一部のバイトが消失したり破損したりしても、通常であればそれらのバイトを復元できます。消失や破損があまりに深刻で復元できない場合は読み取りがエラーになるため、永続ディスクから破損したデータが返されることはありません。</p>
<h3><a name="h.yhvll1f7j4yv" id="h.yhvll1f7j4yv"></a>永続ディスクの管理のしやすさ</h3>
<p>永続ディスクは、接続している Compute Engine のインスタンスとは独立して存在します。そのため永続ディスクは、コンピューティング サービスにローカル接続されているディスクでは通常は不可能な方法で管理できます。</p>
<h4><a name="h.ocubpfffkday" id="h.ocubpfffkday"></a>インスタンスから接続解除可能</h4>
<p>インスタンスのサイズの変更や、実行するソフトウェアの交換やアップグレードのために Compute Engine のインスタンスを停止する必要がある場合でも、関連データは失われません。ボリュームを構築し直す必要もありません。インスタンスを停止して、接続されているボリュームに新しいインスタンスを作成します。</p>
<p>たとえば、<a target="_blank" href="http://www.mysql.com/">MySQL</a>、<a target="_blank" href="https://www.mongodb.org/">MongoDB</a>、<a target="_blank" href="http://cassandra.apache.org/">Cassandra</a> などのデータベースのライフサイクルを見ると、ハードウェアやソフトウェアをこのようにすばやくアップグレードできることでメンテナンスの負荷を大幅に下げることができます。ローカルのエフェメラル ディスクを再構築する必要がないメリットは以下のとおりです:</p>
<ul>
<li>ダウンタイムの削減</li>
<li>アップグレードの高速化</li>
<li>管理の簡略化</li>
<li>インスタンス起動時のネットワーク トラフィックとディスク IO が低減</li>
</ul>
<h4><a name="h.6weg86eazizc" id="h.6weg86eazizc"></a>グローバルにアクセスできるスナップショットにすぐにコピー可能</h4>
<p>永続ディスクでは<a href="https://developers.google.com/compute/docs/disks#snapshots">スナップショット</a>を使って、定期的にバックアップできます。永続ディスクは単一のゾーン内で冗長性がありますが、スナップショットは複数のゾーン間で自動的に複製されます。あるゾーンが災害によって完全に失われた場合、作成したスナップショットから、別のゾーンで新しい永続ディスクを作成して、すぐに復元することができます。エンドユーザーが重要なデータを削除した場合でも、以前のスナップショットから新しい永続ディスクを作成して復元できます。</p>
<p>同じ永続ディスクのスナップショットを繰り返し作成する場合は、インクリメンタルとなります。つまり、前回のスナップショットが保存されてからの変更のみが保存されます。これによって、<a href="http://googlecloudplatform.blogspot.com/2013/10/persistent-disk-backups-using-snapshots.html#gpluscomments">高速なバックアップ</a>と、スナップショットのストレージ費用の削減が可能になります。</p>
<h4>スナップショットからのサイズ変更が可能</h4>
<p>スナップショットから新しい永続ディスク ボリュームを作成する際に、元のボリュームよりも<a target="_blank" href="https://developers.google.com/compute/docs/disks#restoresnapshotlargersize">大きなサイズを指定</a>できます。つまり、デプロイを構築するにあたって、ボリューム サイズを保守的に決めることができるということです。デプロイや初期テストの段階ではボリューム サイズを控えめに設定しておき、スナップショットから新しいボリュームを作成する際にサイズを変更する方が、新しいボリュームを作成して古いボリュームから手動でデータをコピーするよりずっと簡単です。</p>
<h4><a name="h.5seopampg6g6" id="h.5seopampg6g6"></a>読み取りモードで複数のノードに接続可能</h4>
<p>永続ディスクは、読み取りモードで複数のノードに接続できます（読み書き可能なモードのインスタンスにまったく接続していない場合）。Compute Engine の複数のインスタンスに静的コンテンツを配信しても、ストレージの複製費用は発生しません。</p>
<h3><a name="h.nhrjtm7bctwy" id="h.nhrjtm7bctwy"></a>永続ディスクの使いやすさ</h3>
<p>ブロック ストレージには典型的な複雑さや費用でも、Compute Engine の永続ディスクなら避けられるものがあります。</p>
<h4><a name="h.gokibt95gng1" id="h.gokibt95gng1"></a>信頼性と機能における費用とパフォーマンスのトレードオフは不要</h4>
<p>Compute Engine の永続ディスクの費用は、VM に接続されているディスクの一般的な費用とほぼ同程度です。一方、永続ディスクのパフォーマンスは、ローカルの物理ハード ドライブに比べ大幅に優れています。優れたパフォーマンスを得るために、ローカル ディスクの制限に縛られる必要はないのです。</p>
<h4><a name="h.6d45sg9wisnu" id="h.6d45sg9wisnu"></a>パフォーマンスが最高のディスクを探す手間は不要</h4>
<p>永続ディスクのパフォーマンスは一貫しています。ディスク セットを余分に回転させて、パフォーマンスをテストし、最高のディスクのみ選択する必要はなくなりました。破棄する不要なディスクはありません。</p>
<h4><a name="h.cgu2whw72z4o" id="h.cgu2whw72z4o"></a>複数のディスクでのストライプ化は不要</h4>
<p>複数のディスクを RAID アレイにまとめて、パフォーマンスと信頼性を改善する必要はありません。Google がデータを常に複数のディスクにストライプ化しておくので、並列 IO のパフォーマンスと複製ブロックの信頼性が得られます。</p>
<h4><a name="h.h5s64j1h5y56" id="h.h5s64j1h5y56"></a>ボリュームのプリウォームは不要</h4>
<p>ボリュームを追加すると、ボリュームはフルスピードの稼働状態で利用できます。ボリュームをプリウォームして、リソースを無駄に消費する必要はありません。</p>
<h2><a name="h.20oskwvx5asf" id="h.20oskwvx5asf"></a>永続ディスクの適正サイズの選択</h2>
<p>永続ディスク ストレージの購入では通常、必要な容量とパフォーマンスについて検討する必要があり、その両方を満たすディスク ボリュームを購入します。仮想マシンの制限についても検討する必要があります。これについて以下で説明します。</p>
<p>永続ディスクの使用料金は、1 GB あたり月額 0.04 ドルです<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup>。IO に別途課金されることはありません。ディスク費用の予算を計算するために、毎月の使用量を見積もる必要はありません。</p>
<p>永続ディスクのパフォーマンスの上限は、ボリューム サイズを増やしていくことで最大パフォーマンスに達するまで上げることができます。ここで言うパフォーマンスの上限とは、ディスクに対して「持続的な」アクティビティが行われている状態での上限であり、IO レートがピーク時の上限ではありません。多くのアプリケーションでは IO の急増が発生します。そこで Google では、永続ディスクにバースト機能を実装し、ピーク時ではなく持続的なレートに基づいて適正なボリューム サイズを選択できるようにしました。負荷がときどき急増するアプリケーションの場合は、この方法により持続的なコスト削減が可能です。</p>
<p>読み書きに対するパフォーマンスの上限は、「小規模なランダム IO」と「大規模な IO」の 2 つの IO パターンに分けて考えることができます。小規模な読み書きの場合、制限の要因となるのは 1 秒あたりのランダムな入出力操作回数（<a href="http://en.wikipedia.org/wiki/IOPS">IOPS</a>）です。大規模な読み書きの場合、制限の要因となるのは帯域幅です。</p>
<p>1 TB の永続ディスク ボリュームに対する各 IO パターンでのパフォーマンスの上限を、次の表に示します。</p>
<a href="#" name="44b205abf9939194c2601c29d780a0a66f58b802" id="44b205abf9939194c2601c29d780a0a66f58b802"></a><a href="#" name="2" id="2"></a>
<div align="center">
<table class="brdr-table blu-hdr" style="width: 80%;">
<tr>
<td></td>
<th>最大持続 IOPS / TB（リニアに 10 TB まで増大）</th>
<th>最大持続スループット / TB</th>
<th>最大持続スループット / VM</th>
</tr>
<tr>
<th>読み取り</th>
<td>300 IOPS</td>
<td>120 MB/s</td>
<td>180 MB/s</td>
</tr>
<tr>
<th>書き込み</th>
<td>1500 IOPS</td>
<td>90 MB/s</td>
<td>120 MB/s</td>
</tr>
</table>
</div>
<p>The performance increases linearly with the size of the disk. Thus if you require only 60 random reads per volume, you only need 200 GB, but if you require 600 small random read IOPs, then you would purchase at least a 2 TB volume.</p>
<p>VM の最大スループットも、VM 1 台の上限まで、ボリューム サイズとともに増大します。永続ディスクの帯域幅に対する VM の上限は、読み取りの場合 180 MB/s、書き込みの場合 120 MB/s です。一般に VM が大きいほど、帯域幅が高くなります。</p>
<h3>上限</h3>
<p>永続ディスクのサイズの上限は 10 TB です。これは、ランダムな読み取り時の 3000 IOPS またはランダムな書き込み時の 15000 IOPS に相当します。</p>
<h3><a name="h.jr00ue7384mi" id="h.jr00ue7384mi"></a>例</h3>
<p>次の一連の例では、パフォーマンスの要件に応じた永続ディスク サイズの選択方法を示します。</p>
<h4><a name="h.oiyyop5msnju" id="h.oiyyop5msnju"></a>例 1</h4>
<p>データベースのインストール環境（小規模なランダム IO）で、ランダムな書き込みの最大レートとして 300 IOPS が必要だとします:</p>
<img src="/images/articles/ced-price-performance-and-persistence/formula-00.png" alt="">
<p>したがって、200 GB 以上の永続ディスクを購入します。</p>
<h4><a name="h.7p3k6pqwxxss" id="h.7p3k6pqwxxss"></a>例 2</h4>
<p>データベースのインストール環境（小規模なランダム IO）で、ランダムな読み取りの最大レートとして 450 IOPS が必要だとします:</p>
<img src="/images/articles/ced-price-performance-and-persistence/formula-01.png" alt="">
<p>したがって、1,500 GB 以上の永続ディスクを購入します。</p>
<h4><a name="h.d8in6cl5deyd" id="h.d8in6cl5deyd"></a>例 3</h4>
<p>データベースのインストール環境（小規模な書き込み）で、ランダムな書き込みの最大レートとして 4,800 IOPs が必要だとします:</p>
<img src="/images/articles/ced-price-performance-and-persistence/formula-02.png" alt="">
<p>合計で 3,200 GB 以上の永続ディスクが必要です。Compute Engine の単一インスタンスの最大パフォーマンスは 1,800 IOPs（1 コアまたは 2 コア）または 2,400 IOPs（4 コアまたは 8 コア）です。この場合データを次のように分割できます:</p>
<ul>
<li>1 コアまたは 2 コアのインスタンス 3 つで、それぞれ 1,033 GB 以上の永続ディスク、または</li>
<li>4 コアまたは 8 コアのインスタンス 2 つで、それぞれ 1,600 GB 以上の永続ディスク</li>
</ul>
<h3><a name="h.a26ethyoxy8v" id="h.a26ethyoxy8v"></a>上限（サイズ）</h3>
<p>永続ディスクは最大 10 TB です。</p>
<h3><a name="h.n2qmdf4s6j0v" id="h.n2qmdf4s6j0v"></a>ボリュームが小さい場合のパフォーマンス</h3>
<p>永続ディスクのボリュームを小さくすると、最大持続パフォーマンスは低くなります。Google では、すべてのボリュームに最大 1 TB のバースト機能を実装し、短時間の IO の急増に対応できるようにしています。IO の急増が収まると、IO レートは既定の上限まで下がります。</p>
<p>ブート ボリュームは小さくするのが一般的です（デフォルトは 10 GB）。しかし、パッケージ インストール時や起動時の IO の急増にはバースト機能で対応できます。ブート ボリュームに持続的な IO が必要な場合（たとえば積極的にログを記録する場合など）は、10 GB より大きくするとよいでしょう（費用もそれほどかかりません）。多くの場合、ログの記録はブート ボリュームで処理できますが、ログ記録の負荷が大きい場合は、ブート ボリュームを大きくするか、ログ用の大きなボリュームを作成するか、ログを既存の大きなボリュームに書き込むようにします。</p>
<h2>パフォーマンスの概要</h2>
<p>次の表に、一般的なディスク サイズのパフォーマンスと費用をまとめます。</p>
<div align="center">
<table class="brdr-table blu-hdr" style="width: 80%;">
<tbody>
<tr>
<th>ボリューム サイズ（GB）</th>
<th>月額</th>
<th>持続的なランダム読み取り IOPS の上限</th>
<th>持続的なランダム書き込み IOPS の上限</th>
<th>持続的な読み取りスループットの上限（MB/s）</th>
<th>持続的な書き込みスループットの上限（MB/s）</th>
</tr>
<tr>
<td><b>10</b></td>
<td>$0.40</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td><b>50</b></td>
<td>$2</td>
<td>15</td>
<td>75</td>
<td>6</td>
<td>4.5</td>
</tr>
<tr>
<td><b>100</b></td>
<td>$4</td>
<td>30</td>
<td>150</td>
<td>12</td>
<td>9</td>
</tr>
<tr>
<td><b>200</b></td>
<td>$8</td>
<td>60</td>
<td>300</td>
<td>24</td>
<td>18</td>
</tr>
<tr>
<td><b>500</b></td>
<td>$20</td>
<td>150</td>
<td>750</td>
<td>60</td>
<td>45</td>
</tr>
<tr>
<td><b>1000</b></td>
<td>$40</td>
<td>300</td>
<td>1500</td>
<td>120</td>
<td>90</td>
</tr>
<tr>
<td><b>2000</b></td>
<td>$80</td>
<td>600</td>
<td>3000</td>
<td>180</td>
<td>120</td>
</tr>
<tr>
<td><b>5000</b></td>
<td>$200</td>
<td>1500</td>
<td>7500</td>
<td>180</td>
<td>120</td>
</tr>
<tr>
<td><b>10000</b></td>
<td>$400</td>
<td>3000</td>
<td>15000</td>
<td>180</td>
<td>120</td>
</tr>
</tbody>
</table>
</div>
<p>* このボリューム サイズはブート ボリュームにのみ使用することをおすすめします。意義のあるタスクには IO バースト機能が適用されます。</p>
<h2>永続ディスクとハード ドライブの比較</h2>
<p>既存のデプロイで使用しているハード ドライブの IOPS やスループットをテストしたことがない方のために、永続ディスクのパフォーマンスをハード ドライブと比較する上でのおおまかな基準をまとめておきます。次の表は、7200 RPM SATA ドライブと同等のパフォーマンス（一般的には 75 IOPS または 120 MB/s）を得るために必要なボリューム サイズを示しています。</p>
<div align="center">
<table class="brdr-table blu-hdr" style="width: 90%;">
<tbody>
<tr>
<th>IO パターン</th>
<th>一般的な 7200 RPM SATA ドライブと同等のボリューム サイズ</th>
</tr>
<tr>
<td>小規模でランダムな読み取り 75 IOPS</td>
<td>250 GB</td>
</tr>
<tr>
<td>小規模でランダムな書き込み 75 IOPS</td>
<td>50 GB</td>
</tr>
<tr>
<td>120 MB/s ストリーミング読み取り</td>
<td>1,000 GB</td>
</tr>
<tr>
<td>120 MB/s ストリーミング書き込み</td>
<td>1,333 GB</td>
</tr>
</tbody>
</table>
</div>
<h2><a name="h.c4iq5z84qyvu" id="h.c4iq5z84qyvu"></a>まとめ</h2>
<p>Google Compute Engine の永続ディスクでは、パフォーマンスが高く、実装に一貫性があり、安価なネットワーク ブロック ストレージ サービスをご利用になれます。Google はこれによって、ローカル ハード ドライブ（とその制限）を過去のものにできると考えています。</p>
<p>Google Compute Engine の永続ディスクを使用する理由:</p>
<ul>
<li>パフォーマンス（高くて一貫性がある）</li>
<li>費用（小さくて予測可能）</li>
<li>安全性（冗長性、暗号化、チェックサム検証）</li>
<li>管理（シンプルで柔軟）</li>
</ul>
<p>Google は、ますます厳しくなる作業負荷や顧客要件を満たすために、永続ディスクの機能とパフォーマンスの改善を続けます。</p>
<h2><a name="h.x8nxc43ulxgk" id="h.x8nxc43ulxgk"></a>参考資料とリソース</h2>
<p>Google Compute Engine の永続ディスクについて詳しくは、以下をご覧ください:</p>
<ul>
<li>主要ドキュメント<br>
<a target="_blank" href="https://developers.google.com/compute/docs/disks">https://developers.google.com/compute/docs/disks</a></li>
<li>料金<br>
<a target="_blank" href="https://developers.google.com/compute/pricing#persistentdisk">https://developers.google.com/compute/pricing#persistentdisk</a></li>
<li>Google I/O 2013 でのプレゼンテーション<br>
<a target="_blank" href="https://developers.google.com/events/io/sessions/350753683">https://developers.google.com/events/io/sessions/350753683</a></li>
<li>Compute Engine 永続ディスクのスナップショット<br>
<a target="_blank" href="http://googlecloudplatform.blogspot.com/2013/10/persistent-disk-backups-using-snapshots.html">http://googlecloudplatform.blogspot.com/2013/10/persistent-disk-backups-using-snapshots.html</a></li>
<li>新しい永続ディスク - 高速かつ安価で予測可能な Google Compute Engine のための永続ディスク<br>
<a target="_blank" href="http://googlecloudplatform.blogspot.com/2013/12/the-new-persistent-disk-faster-cheaper-and-predictable-for-compute-engine.html">http://googlecloudplatform.blogspot.com/2013/12/the-new-persistent-disk-faster-cheaper-and-predictable-for-compute-engine.html</a></li>
<li>永続ディスクの管理を改善する<br>
<a target="_blank" href="http://googlecloudplatform.blogspot.com/2014/03/improvements-for-managing-persistent-disks.html">http://googlecloudplatform.blogspot.com/2014/03/improvements-for-managing-persistent-disks.html</a></li>
</ul>
<br>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> 本ドキュメントの執筆時点。最新の料金については<a target="_blank" href="https://developers.google.com/compute/pricing#persistentdisk">こちらのページ</a>でご確認ください。</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">このドキュメントへのフィードバック</a><br>
<br></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'ja',
        'region': 'japac',
        'language': 'ja'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>